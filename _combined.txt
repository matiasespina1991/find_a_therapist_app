.
├── README.md
├── _combined.txt
├── analysis_options.yaml
├── concatenate_dart_files.sh
├── firebase-debug.log
├── firebase.json
├── lib
│   ├── _bin
│   │   ├── _demo_widgets_screen.dart
│   │   └── config.dart
│   ├── _mock_data
│   │   └── _mock_therapists.dart
│   ├── app_settings
│   │   ├── app_general_settings.dart
│   │   ├── app_info.dart
│   │   ├── auth_config.dart
│   │   ├── env_settings.dart
│   │   ├── language_settings.dart
│   │   └── theme_settings.dart
│   ├── assets
│   │   ├── app_icons
│   │   │   ├── logo1.png
│   │   │   ├── logo2.jpg
│   │   │   ├── logo3.png
│   │   │   ├── lupe1.png
│   │   │   └── lupe2.webp
│   │   ├── app_logo
│   │   │   └── logo.png
│   │   ├── extra_dash_flags
│   │   │   ├── ac.svg
│   │   │   ├── as.svg
│   │   │   ├── do.svg
│   │   │   ├── in.svg
│   │   │   └── is.svg
│   │   ├── icons
│   │   │   ├── gold-plan-badge.png
│   │   │   └── verified-badge.png
│   │   ├── images
│   │   ├── lottie_animations
│   │   │   ├── animation.json
│   │   │   ├── animation10.json
│   │   │   ├── animation11.json
│   │   │   ├── animation2.json
│   │   │   ├── animation3.json
│   │   │   ├── animation4.json
│   │   │   ├── animation5.json
│   │   │   ├── animation6.json
│   │   │   ├── animation7.json
│   │   │   ├── animation8.json
│   │   │   ├── animation9.json
│   │   │   └── searching_for_a_doctor.lottie
│   │   └── placeholders
│   │       └── default_profile_picture.jpg
│   ├── firebase_options.dart
│   ├── generated
│   │   ├── intl
│   │   │   ├── messages_all.dart
│   │   │   ├── messages_de.dart
│   │   │   ├── messages_en.dart
│   │   │   └── messages_es.dart
│   │   └── l10n.dart
│   ├── globals.dart
│   ├── l10n
│   │   ├── intl_de.arb
│   │   ├── intl_en.arb
│   │   └── intl_es.arb
│   ├── main.dart
│   ├── models
│   │   ├── current_user_data.dart
│   │   ├── gemini_tags_response_model.dart
│   │   ├── general_models.dart
│   │   ├── term_index_model.dart
│   │   ├── theme_models.dart
│   │   └── therapist_model.dart
│   ├── providers
│   │   ├── auth_provider.dart
│   │   ├── locale_provider.dart
│   │   ├── providers_all.dart
│   │   ├── theme_provider.dart
│   │   ├── therapists_languages_provider.dart
│   │   └── translate_profiles_providers.dart
│   ├── routes
│   │   └── routes.dart
│   ├── screens
│   │   ├── _example_screen.dart
│   │   ├── admin
│   │   │   └── debug_screen
│   │   ├── common
│   │   │   ├── all_therapists_screen
│   │   │   ├── aspects_screen
│   │   │   ├── loading_screen
│   │   │   ├── login_screen
│   │   │   ├── not_found_screen
│   │   │   ├── settings_screen
│   │   │   ├── therapist_public_profile_screen
│   │   │   └── welcome_main_screen
│   │   ├── therapist_area
│   │   │   └── therapist_personal_profile_screen
│   │   └── user_area
│   │       ├── therapist_result_screen
│   │       ├── user_profile_screen
│   │       └── user_request_screen
│   ├── services
│   │   ├── connectivity_service.dart
│   │   ├── error_reporting_service.dart
│   │   ├── firestore_service.dart
│   │   ├── gemini_service.dart
│   │   ├── profiles_translate_delegate.dart
│   │   └── speech_to_text_service.dart
│   ├── theme
│   │   └── main_theme
│   │       ├── buttons_theme.dart
│   │       ├── chip_theme.dart
│   │       ├── input_theme.dart
│   │       └── main_theme.dart
│   ├── utils
│   │   ├── admin
│   │   │   ├── _list_of_new_therapists.dart
│   │   │   ├── add_current_user_as_therapist.dart
│   │   │   ├── add_current_user_to_database.dart
│   │   │   ├── add_terms_as_subcategory.dart
│   │   │   ├── add_therapist.dart
│   │   │   ├── add_therapists_in_batch.dart
│   │   │   ├── consolidate_terms.dart
│   │   │   ├── find_best_therapist_by_aspects.dart
│   │   │   ├── log_all_terms.dart
│   │   │   ├── log_all_therapists.dart
│   │   │   ├── to_capital_case.dart
│   │   │   ├── update_all_therapists_aspects.dart
│   │   │   ├── update_props_on_therapists_docs.dart
│   │   │   └── update_terms_index_from_all_therapist.dart
│   │   ├── debug
│   │   │   ├── error_code_to_text.dart
│   │   │   ├── log_configurations.dart
│   │   │   └── notify_that_app_is_runing_in_debug_mode.dart
│   │   ├── functions
│   │   │   └── images_utils.dart
│   │   ├── ui
│   │   │   └── get_dash_flag_by_country_code.dart
│   │   └── validation
│   │       └── is_email_valid.dart
│   └── widgets
│       ├── AppScaffold
│       │   └── app_scaffold.dart
│       ├── AspectSection
│       │   └── aspect_section.dart
│       ├── GooglePlacesAutocompleteTextField
│       │   └── google_place_autocomplete_text_field.dart
│       ├── LoadingCircle
│       │   └── loading_circle.dart
│       ├── LocationSelectionModal
│       │   └── location_selection_modal.dart
│       ├── ModalTopChip
│       │   └── modal_top_chip.dart
│       ├── NotificationModal
│       │   └── notification_modal.dart
│       ├── NotificationSnackbar
│       │   └── notification_snackbar.dart
│       ├── Skeletons
│       │   └── SkeletonTherapistCard
│       ├── ThemeAppBar
│       │   └── template_app_bar.dart
│       ├── ThemeFloatingSpeedDialMenu
│       │   └── theme_floating_speed_dial_menu.dart
│       ├── ThemeInputTextField
│       │   └── theme_input_text_field.dart
│       └── TherapistListCard
│           └── therapist_list_card.dart
├── pubspec.lock
├── pubspec.yaml
├── rename_imports.sh
└── template_app.iml

61 directories, 112 files
///// pubspec.yaml /////
name: findatherapistapp
description: "An app to easily find the perfect therapist."

publish_to: 'none' # Remove this line if you wish to publish to pub.dev

version: 1.0.0+1

environment:
  sdk: '>=3.2.6 <4.0.0'

dependencies:
  flutter:
    sdk: flutter
  flutter_localizations:
    sdk: flutter

  # Cupertino Icons is a Flutter plugin for using Cupertino icons in a Flutter app. (Example of use: Icon(CupertinoIcons.share))
  cupertino_icons: ^1.0.8
  # Riverpod is a Flutter plugin for managing state in a Flutter app.
  flutter_riverpod: ^2.5.1
  # Flutter Secure Storage is a Flutter plugin for storing data securely on the device.
  flutter_secure_storage: ^9.2.2
  # Google Fonts is a Flutter plugin for using Google Fonts in a Flutter app.
  google_fonts: ^6.2.1
  # Fluttertoast is a Flutter plugin for showing toast messages in a Flutter app.
  fluttertoast: ^8.2.6
  # Google Sign In is a Flutter plugin for signing with Google. It is a wrapper around the native Google Sign In libraries.
  google_sign_in: ^6.2.1
  # Sign In Button is a Flutter plugin for creating sign-in buttons in a Flutter app.
  sign_in_button: ^3.2.0
  # Go Router is a Flutter plugin for routing in a Flutter app.
  go_router: ^14.2.0
  # Google Generative AI is a Flutter plugin for using Google Generative AI in a Flutter app.
  google_generative_ai: ^0.4.3
  # Speech to Text is a Flutter plugin for converting speech to text in a Flutter app.
  speech_to_text: ^6.6.0
  # Country Picker is a Flutter plugin for selecting countries in a Flutter app.
  country_picker: ^2.0.26
  # Intl is a Flutter plugin for internationalization in a Flutter app.
  intl: any
  # Flutter Localized Locales is a Flutter plugin for using localized locales in a Flutter app.
  flutter_localized_locales: ^2.0.5
  # Expandable is a Flutter plugin for creating expandable widgets in a Flutter app.
  expandable: ^5.0.1
  # Google Mklit Translation is a Flutter plugin for translating text in a Flutter app.
  google_mlkit_translation: ^0.11.0
  # Number Paginator is a Flutter plugin for creating number paginators in a Flutter app.
  number_paginator: ^0.4.1
  # Google Places Autocomplete Text Field is a Flutter plugin for using Google Places Autocomplete in a Flutter app.
  google_places_autocomplete_text_field: ^0.1.3
  # Animated Do is a Flutter plugin for creating animations in a Flutter app.
  animate_do: ^3.3.4



#  # -----------------  GENERAL PACKAGES  -----------------
#  # Url Launcher is a Flutter plugin for launching a URL in the mobile platform. Supports iOS and Android.
#  url_launcher: ^6.3.0
#  # Cached network image is a Flutter library to show images from the internet and keep them in the cache directory.
  cached_network_image: ^3.3.1
#  # Google Fonts is a Flutter plugin for using Google Fonts in a Flutter app.
#  google_fonts: ^6.2.1
#  # Flutter Email Validator is a Flutter plugin for validating email addresses in a Flutter app.
#  email_validator: ^2.1.17
#  # Permission Handler is a Flutter plugin for requesting permissions in a Flutter app.
#  permission_handler: ^11.3.1
#  # Image Picker is a plugin for selecting images from the Android and iOS image library, and taking new pictures with the camera:
#  image_picker: ^1.1.2
  # Skeletonizer is a Flutter plugin for creating skeleton loading animations in a Flutter app.
  skeletonizer: ^1.3.0

  # Device Info Plus is a Flutter plugin for getting information about the device the app is running on.
  device_info_plus: ^10.1.0
  # Package Info Plus is a Flutter plugin for getting information about the package the app is running on.
  package_info_plus: ^8.0.0
#  # HTTP is a Flutter plugin for performing HTTP requests. It is a wrapper around the Dart http package.
#  http: ^1.2.1
#  # Webview is a Flutter plugin for rendering web content in a Flutter widget.
#  webview_flutter: ^4.8.0
#  # Share Plus is a Flutter plugin for sharing content (Links to the app, text, emails, files, etc.) from a Flutter app to other apps.
#  share_plus: ^9.0.0
#  # Add 2 Calendar is a Flutter plugin for adding events to the calendar in a Flutter app.
#  add_2_calendar: ^3.0.1
#  # Geo Locator is a Flutter plugin for getting the location of the device in a Flutter app.
#  geolocator: ^12.0.0
#  # Map Launcher is a Flutter plugin for launching maps in a Flutter app.
#  map_launcher: ^2.0.1
#  # Google Maps Flutter is a Flutter plugin for embedding Google Maps in a Flutter app.
#  google_maps_flutter: ^2.7.0
  # Connectivity Plus is a Flutter plugin for getting information about the network connectivity in a Flutter app.
  connectivity_plus: ^6.0.3
#  # Expandable is a Flutter plugin for creating expandable widgets in a Flutter app.
#  expandable: ^5.0.1
#  # Photo View is a Flutter plugin for showing photos in a full-screen view with zooming and panning gestures.
#  photo_view: ^0.15.0
#  # Percent Indicator is a Flutter plugin for showing percentage indicators in a Flutter app.
#  percent_indicator: ^3.0.1

#  # -----------------  WIDGET DESIGN PACKAGES  -----------------
  # Flutter Speed Dial is a Flutter plugin for creating a speed dial menu widget in a Flutter app.
  flutter_speed_dial: ^7.0.0
#  # Badges is a Flutter plugin for creating fancy animated badges in a Flutter app.
  badges: ^3.1.2
#  # Flutter Native Splash is a Flutter plugin for creating a splash screen in a Flutter app.
#  flutter_native_splash: ^2.4.0
#  # Another Flushbar is a Flutter plugin for creating custom snackbars in a Flutter app.
#  another_flushbar: ^1.12.30
#  # Awesome Dialog is a Flutter plugin for creating awesome dialogs in a Flutter app.
#  awesome_dialog: ^3.2.1
#  # Flutter Staggered Grid View is a Flutter plugin for creating staggered grid views in a Flutter app.
#  flutter_staggered_grid_view: ^0.7.0
#  # Animated Toggle Switch is a Flutter plugin for creating animated toggle switches in a Flutter app.
#  animated_toggle_switch: ^1.0.0
#  #Flutter Typeahead is a Flutter input where you can show suggestions to users as they type.
#  flutter_typeahead: ^2.0.0
#  # Mesh Gradient is a Flutter plugin for creating mesh gradients in a Flutter app.
#  mesh_gradient: ^1.3.6

  # -----------------  ANIMATIONS  -----------------
  # Lottie is a Flutter plugin for using Lottie animations in a Flutter app.
  lottie: ^3.1.2

#  # -----------------  FONT PACKAGES  -----------------
#  # Auto Size Text is a Flutter plugin for creating auto-size text in a Flutter app.
#  auto_size_text: ^3.0.0

#  # -----------------  ICONS PACKAGES  -----------------
#  # Material Design Icons is a Flutter plugin for using Material Design icons in a Flutter app. (Example of use: Icon(MdiIcons.add))
#  material_design_icons_flutter: ^7.0.7296
#  # Font Awesome Icons is a Flutter plugin for using Font Awesome icons in a Flutter app. (Example of use: Icon(FontAwesomeIcons.addressBook))
#  font_awesome_flutter: ^10.7.0
#  # Icofont Icons is a Flutter plugin for using Icofont icons in a Flutter app. (Example of use: Icon(IcoFontIcons.addressBook))
#  icofont_flutter: ^1.4.0

#  # -----------------  MEDIA PACKAGES  -----------------
#  # Video Player is a Flutter plugin for playing videos in a Flutter app.
#  video_player: ^2.8.7
#  # Audio Player is a Flutter plugin for playing audio in a Flutter app.
#  audioplayers: ^6.0.0

#  # -----------------  UI THEMES  -----------------
#  # Macos UI is a Flutter plugin for creating MacOS themes in a Flutter app.
#  macos_ui: ^2.0.7
#  # Chicago Theme is a Flutter plugin for creating Chicago themes in a Flutter app.
#  chicago_theme: ^0.4.3-dev
#  # Win32 GUI is a Flutter plugin for creating Win32 GUI themes in a Flutter app.
#  win32_gui 1.1.5

# ----------------- FIREBASE PACKAGES -----------------
#  # Firebase Core is a Flutter plugin to use the Firebase platform services.
  firebase_core: ^3.1.1
#  # Flutter Auth is a Flutter plugin that enables Android and iOS authentication using passwords, phone numbers, and identity providers like Google, Facebook, and Twitter.
  firebase_auth: ^5.1.1
#  # Cloud Firestore is a flexible, scalable database for mobile, web, and server development from Firebase and Google Cloud Platform.
  cloud_firestore: ^5.1.0

  country_state_city: ^0.1.6
  dash_flags: ^0.1.1
  flutter_svg: ^2.0.10+1
  image_picker: ^1.1.2
  #  # Firebase Database is a Flutter plugin to use the Firebase Realtime Database API and allow storing and syncing data with a NoSQL cloud database.
#  firebase_database: ^11.0.1
#  # Firebase Storage is a Flutter plugin to use the Firebase Cloud Storage API and allow uploading, downloading, and deleting files in the cloud.
  firebase_storage: ^12.0.1
#  # Firebase Messaging is a Flutter plugin to use the Firebase Cloud Messaging (FCM) API and allow sending push notifications to Android and iOS users.
#  firebase_messaging: ^15.0.1
#  # Firebase In-App Messaging is a Flutter plugin to use the Firebase In-App Messaging API and allow sending in-app messages to Android and iOS users.
#  firebase_in_app_messaging: ^0.8.0+1
#  # Firebase Crashlytics is a Flutter plugin to use the Firebase Crashlytics API and allow sending crash reports to Firebase.
#  firebase_crashlytics: ^4.0.1
#  # Firebase Analytics is a Flutter plugin to use the Firebase Analytics API and allow sending events to Google Analytics.
#  firebase_analytics: ^11.0.1
#  # Firebase Performance Monitoring is a Flutter plugin to use the Firebase Performance Monitoring API and allow sending performance data to Firebase.
#  firebase_performance: ^0.10.0+1
#  # Firebase Remote Config is a Flutter plugin to use the Firebase Remote Config API and allow fetching remote configuration values from Firebase.
#  firebase_remote_config: ^5.0.1


dev_dependencies:
  flutter_test:
    sdk: flutter
  flutter_lints: ^4.0.0
  intl_utils: ^2.8.7
  flutter_launcher_icons: "^0.13.1"

flutter_launcher_icons:
  android: "launcher_icon"
  ios: true
  image_path: "lib/assets/app_icons/logo3.png"
  min_sdk_android: 23


flutter:

  uses-material-design: true

  # To add assets to your application, add an assets section, like this:
  # assets:
  #   - images/a_dot_burr.jpeg
  #   - images/a_dot_ham.jpeg

  # To add entire folders of assets to your application, add an assets section, like this:
  assets:
    - lib/assets/lottie_animations/
    - lib/assets/images/
    - lib/assets/icons/
    - lib/assets/app_icons/
    - lib/assets/app_logo/
    - lib/assets/placeholders/
    - lib/assets/extra_dash_flags/


  # fonts:
  #   - family: Schyler
  #     fonts:
  #       - asset: fonts/Schyler-Regular.ttf
  #       - asset: fonts/Schyler-Italic.ttf
  #         style: italic
  #   - family: Trajan Pro
  #     fonts:
  #       - asset: fonts/TrajanPro.ttf
  #       - asset: fonts/TrajanPro_Bold.ttf
  #         weight: 700
  #


///// lib/app_settings/app_general_settings.dart /////
import '../routes/routes.dart';

class AppGeneralSettings {
  static const bool useTopAppBar = false;
  static const bool useFloatingSpeedDialMenu = true;
  static const bool useAppDrawerMenu = false;
  static const String minimumiOSVersion =
      '13.0'; // Set this manually in Xcode & Podfile
  static const String minimumAndroidVersion =
      '23'; // Set this manually in android/app/build.gradle
}

class DebugConfig {
  static const bool debugMode = true;
  static const String debugDatabaseId = 'debug-database';
  static const bool showDebugPrints = false;
  static RouteConfig debugScreen = Routes.userRequestScreen;
  static const forceDebugScreen =
      false; // If true, the route set in debugScreen will be shown and screen protection will be ignored
  static const bool bypassLoginScreen =
      false; // If true, login screen will be skipped
  // static const bool alwaysAllowNavigation =
  //     true;
}

///// lib/app_settings/app_info.dart /////
class AppInfo {
  static const String appName = 'FindYourTherapist';
}

///// lib/app_settings/auth_config.dart /////
class AuthConfig {
  static const bool useProtectedRoutes = true;
  static const bool useFirebase = true;
  static const bool allowGoogleSignIn = true;
  //TODO: Add scope functionality:
  static const List<String> googleSignInScopes = ['email'];
  static const bool allowFacebookSignIn = false;
  static const bool allowAppleSignIn = false;
  static const bool allowAnonymousSignIn = false;
  static const bool allowEmailSignIn = false;
}

///// lib/main.dart /////
import 'package:country_picker/country_picker.dart';
import 'package:findatherapistapp/routes/routes.dart';

import 'package:firebase_core/firebase_core.dart';
import 'package:flutter/material.dart';
import 'package:flutter_localizations/flutter_localizations.dart';
import 'package:flutter_localized_locales/flutter_localized_locales.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:skeletonizer/skeletonizer.dart';
import 'package:findatherapistapp/providers/providers_all.dart';
import 'app_settings/auth_config.dart';
import 'globals.dart';
import 'app_settings/app_info.dart';
import 'app_settings/language_settings.dart';
import 'app_settings/theme_settings.dart';
import 'theme/main_theme/main_theme.dart';
import 'utils/debug/log_configurations.dart';
import 'generated/l10n.dart';

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await initializeApp();
  logConfigurations();
  runApp(const ProviderScope(child: MyApp()));
}

Future<void> initializeApp() async {
  if (AuthConfig.useFirebase) {
    try {
      await Firebase.initializeApp();
    } catch (e) {
      debugPrint('Error: Firebase initialization failed. $e');

      ///TODO: Show an error screen here or retry the initialization.
    }
  }
}

class MyApp extends ConsumerWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final themeNotifier = ref.watch(themeProvider);
    final localeNotifier = ref.watch(localeProvider);
    final isDarkMode = themeNotifier.themeMode == ThemeMode.dark;

    return SkeletonizerConfig(
      data: SkeletonizerConfigData(
          effect: ShimmerEffect(
            baseColor: isDarkMode
                ? ThemeSettings.seedColor.withOpacity(0.1)
                : Colors.grey[300]!, // Color base del shimmer
            highlightColor: isDarkMode
                ? Colors.grey.withOpacity(0.25)
                : Colors.grey[100]!, // Color de resaltado del shimmer
            duration: const Duration(milliseconds: 2500),
            begin: Alignment.topLeft,
            end: Alignment.bottomRight,
          ),
          enableSwitchAnimation: true,
          containersColor: ThemeSettings.forceSeedColor
              ? ThemeSettings.seedColor
              : Colors.grey),
      child: MaterialApp.router(
        scaffoldMessengerKey: snackbarKey,
        title: AppInfo.appName,
        theme: MainTheme.lightTheme,
        darkTheme: MainTheme.darkTheme,
        themeMode: themeNotifier.themeMode,
        locale: localeNotifier.locale,
        supportedLocales: LanguageSettings.supportedLocales
            .map((e) => Locale.fromSubtags(languageCode: e))
            .toList(),
        localizationsDelegates: const [
          LocaleNamesLocalizationsDelegate(),
          CountryLocalizations.delegate,
          S.delegate,
          GlobalMaterialLocalizations.delegate,
          GlobalWidgetsLocalizations.delegate,
          GlobalCupertinoLocalizations.delegate,
        ],
        localeResolutionCallback: (locale, supportedLocales) {
          if (LanguageSettings.forceDefaultLanguage) {
            return const Locale(LanguageSettings.appDefaultLanguage);
          }
          if (locale != null) {
            for (var supportedLocale in supportedLocales) {
              if (supportedLocale.languageCode == locale.languageCode) {
                return supportedLocale;
              }
            }
          }
          return supportedLocales.first;
        },
        routerDelegate: Routes.router.routerDelegate,
        routeInformationParser: Routes.router.routeInformationParser,
        routeInformationProvider: Routes.router.routeInformationProvider,
      ),
    );
  }
}

///// lib/providers/providers_all.dart /////
import 'package:findatherapistapp/providers/therapists_languages_provider.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:findatherapistapp/providers/auth_provider.dart';
import 'package:findatherapistapp/providers/locale_provider.dart';
import 'package:findatherapistapp/providers/theme_provider.dart';

import '../services/connectivity_service.dart';

final authProvider = ChangeNotifierProvider((ref) => AuthorizationProvider());
final themeProvider = ChangeNotifierProvider((ref) => ThemeProvider());
final localeProvider = ChangeNotifierProvider((ref) => LocaleProvider());
final connectivityProvider =
    ChangeNotifierProvider((ref) => ConnectivityService());
final therapistsLanguagesProvider =
    ChangeNotifierProvider((ref) => TherapistsLanguagesProvider());

///// lib/providers/auth_provider.dart /////
import 'package:flutter/material.dart';
import 'package:flutter_secure_storage/flutter_secure_storage.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:google_sign_in/google_sign_in.dart';
import 'package:findatherapistapp/app_settings/app_general_settings.dart';
import 'package:findatherapistapp/app_settings/auth_config.dart';

class AuthorizationProvider extends ChangeNotifier {
  final FlutterSecureStorage storage = const FlutterSecureStorage();
  final FirebaseAuth? _firebaseAuth =
      AuthConfig.useFirebase ? FirebaseAuth.instance : null;
  final GoogleSignIn _googleSignIn =
      GoogleSignIn(scopes: AuthConfig.googleSignInScopes);
  String? _authToken;
  User? _user;
  bool _isLoading = true;

  AuthorizationProvider() {
    _initializeUser();
  }

  String? get authToken => _authToken;
  User? get user => _user;
  bool get isLoading => _isLoading;

  Future<void> _initializeUser() async {
    if (AuthConfig.useFirebase) {
      _user = _firebaseAuth?.currentUser;
      if (_user != null) {
        _authToken = _user!.uid;
      }
    } else {
      _authToken = await storage.read(key: 'auth_token');
    }

    if (DebugConfig.debugMode || DebugConfig.forceDebugScreen) {
      if (_authToken == null && _user == null) {
        debugPrint('[User is not authenticated.]');
      } else {
        debugPrint('[User is authenticated.]');
      }
    }

    if ((DebugConfig.bypassLoginScreen || DebugConfig.forceDebugScreen) &&
        (_authToken == null && _user == null)) {
      debugPrint('Signing user automatically...');
      GoogleSignInAccount? currentUser = await _googleSignIn.signIn();
      if (currentUser != null) {
        _user = await _handleSignIn(currentUser);
        if (_user != null) {
          _authToken = _user?.uid;
          await setAuthToken(_authToken!);
          notifyListeners();
        }
      }
    }

    _isLoading = false;
    notifyListeners();

    _googleSignIn.onCurrentUserChanged
        .listen((GoogleSignInAccount? account) async {
      if (account != null) {
        _user = await _handleSignIn(account);
        if (_user != null) {
          _authToken = _user?.uid;
          await setAuthToken(_authToken!);
        }
      } else {
        _user = null;
        _authToken = null;
      }
      notifyListeners();
    });

    GoogleSignInAccount? currentUser = await _googleSignIn.signInSilently();
    if (currentUser != null) {
      _user = await _handleSignIn(currentUser);
      if (_user != null) {
        _authToken = _user?.uid;
        await setAuthToken(_authToken!);
        notifyListeners();
      }
    }
  }

  Future<User?> _handleSignIn(GoogleSignInAccount account) async {
    try {
      final GoogleSignInAuthentication googleAuth =
          await account.authentication;
      final AuthCredential credential = GoogleAuthProvider.credential(
        idToken: googleAuth.idToken,
        accessToken: googleAuth.accessToken,
      );

      if (AuthConfig.useFirebase) {
        final UserCredential authResult =
            await _firebaseAuth!.signInWithCredential(credential);
        return authResult.user;
      }
      return null;
    } catch (e) {
      debugPrint('Error during Google sign-in: $e');
      return null;
    }
  }

  Future<void> setAuthToken(String token) async {
    await storage.write(key: 'auth_token', value: token);
    _authToken = token;
    notifyListeners();
  }

  Future<void> clearAuthToken() async {
    await storage.delete(key: 'auth_token');
    _authToken = null;
    _user = null;
    debugPrint('Auth token cleared. User will be logged out.');
    notifyListeners();
  }

  Future<void> signOut(BuildContext context) async {
    if (DebugConfig.bypassLoginScreen) {
      debugPrint(
          'Error: Bypass Login Screen is on. Disable it from AppGeneralSettings.bypassLoginScreen in order to proceed with sign out.');
      return;
    }
    await clearAuthToken();
    if (AuthConfig.useFirebase) {
      await _firebaseAuth?.signOut();
    }

    if (AuthConfig.allowGoogleSignIn) {
      await _googleSignIn.signOut();
    }
  }

  bool get isAuthenticated =>
      !isLoading &&
      (DebugConfig.bypassLoginScreen ||
          (_authToken != null && _authToken!.isNotEmpty));

  Future<bool> signInWithEmail(String email, String password) async {
    bool success = false;
    try {
      debugPrint('Signing in with email/password...');

      if (AuthConfig.useFirebase) {
        final UserCredential authResult = await _firebaseAuth!
            .signInWithEmailAndPassword(email: email, password: password);
        _authToken = authResult.user!.uid;
        _user = authResult.user;
        await setAuthToken(_authToken!);
      } else {
        _authToken = email;
        await setAuthToken(_authToken!);
      }

      notifyListeners();
      success = true;
      debugPrint('User logged in successfully.✅');
      return success;
    } catch (error) {
      debugPrint('Error during email/password Sign In: ${error.toString()}');
      success = false;
      return success;
    }
  }

  Future<bool> signInWithGoogle() async {
    bool success = false;
    if (AuthConfig.allowGoogleSignIn) {
      try {
        debugPrint('Signing in with Google...');

        final GoogleSignInAccount? googleUser = await _googleSignIn.signIn();
        if (googleUser != null) {
          debugPrint('Google Sign In successful.');
          final GoogleSignInAuthentication googleAuth =
              await googleUser.authentication;
          final credential = GoogleAuthProvider.credential(
            accessToken: googleAuth.accessToken,
            idToken: googleAuth.idToken,
          );

          if (AuthConfig.useFirebase) {
            final UserCredential? authResult =
                await _firebaseAuth?.signInWithCredential(credential);
            _authToken = authResult?.user!.uid;
            _user = authResult?.user;
            await setAuthToken(_authToken!);
          } else {
            _authToken = googleAuth.accessToken;
            await setAuthToken(_authToken!);
          }

          notifyListeners();
          success = true;
          debugPrint('User logged in successfully.');
          return success;
        }
      } catch (error) {
        debugPrint(
            'Error trying to signing in user using Google: ${error.toString()}');
        success = false;
        return success;
      }
    }
    return success;
  }
}

///// lib/widgets/AppScaffold/app_scaffold.dart /////
import 'dart:async';
import 'dart:ui';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:lottie/lottie.dart';
import 'package:findatherapistapp/app_settings/app_general_settings.dart';
import 'package:findatherapistapp/app_settings/auth_config.dart';
import 'package:findatherapistapp/providers/providers_all.dart';
import 'package:findatherapistapp/widgets/NotificationModal/notification_modal.dart';
import 'package:findatherapistapp/widgets/NotificationSnackbar/notification_snackbar.dart';
import 'package:skeletonizer/skeletonizer.dart';
import '../../app_settings/theme_settings.dart';
import '../../generated/l10n.dart';
import '../../models/general_models.dart';
import '../../routes/routes.dart';
import '../../screens/common/loading_screen/loading_screen.dart';
import '../ThemeAppBar/template_app_bar.dart';
import '../ThemeFloatingSpeedDialMenu/theme_floating_speed_dial_menu.dart';

class AppScaffold extends ConsumerStatefulWidget {
  final Widget body;
  final bool hideFloatingSpeedDialMenu;
  final String appBarTitle;
  final bool isProtected;
  final bool? useSafeArea;
  final ScrollPhysics? scrollPhysics;
  final LottieAnimationBackground? backgroundAnimation;
  final LottieAnimationBackground? backgroundAnimationDarkMode;
  final bool useTopAppBar;
  final bool showScreenTitleInAppBar;
  final EdgeInsetsGeometry? scaffoldPadding;
  final bool ignoreGlobalPadding;
  final List<Widget>? actions;
  final bool? centerTitle;
  final bool setFloatingSpeedDialToLoadingMode;
  final Function()? backButton;
  const AppScaffold(
      {super.key,
      required this.body,
      required this.appBarTitle,
      required this.isProtected,
      this.useSafeArea,
      this.hideFloatingSpeedDialMenu = false,
      this.scrollPhysics,
      this.backgroundAnimation,
      this.backgroundAnimationDarkMode,
      this.useTopAppBar = false,
      this.showScreenTitleInAppBar = true,
      this.scaffoldPadding,
      this.ignoreGlobalPadding = false,
      this.actions,
      this.centerTitle,
      this.setFloatingSpeedDialToLoadingMode = false,
      this.backButton});

  @override
  AppScaffoldState createState() => AppScaffoldState();
}

class AppScaffoldState extends ConsumerState<AppScaffold> {
  bool _connectivityChecked = false;
  bool _userWentOffline = false;
  Timer? _connectivityTimer;

  @override
  void initState() {
    super.initState();

    final String debugRouteName = DebugConfig.debugScreen.name;

    if (DebugConfig.forceDebugScreen && debugRouteName.isNotEmpty) {
      bool navigationAllowed = true;
      // if (DebugConfig.alwaysAllowNavigation) {
      //   navigationAllowed = true;
      // }
      debugPrint(
          '[DebugConfig.forceDebugScreen is set to true. Target screen is: $debugRouteName. Navigation ${navigationAllowed ? 'allowed' : 'is blocked'}.');
    }
  }

  @override
  void dispose() {
    _connectivityTimer?.cancel();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final auth = ref.watch(authProvider);
    final connectivity = ref.watch(connectivityProvider);

    if (auth.isLoading && !auth.isAuthenticated) {
      return const LoadingScreen();
    }

    _handleProtectedRoutes(auth);
    _checkConnectivity(connectivity);

    return SafeArea(
      bottom: widget.useSafeArea ?? ThemeSettings.useSafeArea,
      top: widget.useSafeArea ?? ThemeSettings.useSafeArea,
      child: Scaffold(
        appBar: (AppGeneralSettings.useTopAppBar || widget.useTopAppBar)
            ? ThemeAppBar(
                backButton: widget.backButton,
                appBarHeight: ThemeSettings.appBarHeight,
                centerTitle: widget.centerTitle,
                actions: widget.actions,
                title: widget.showScreenTitleInAppBar ? widget.appBarTitle : '',
              )
            : null,
        body: Stack(
          fit: StackFit.expand,
          children: [
            _buildBackgroundAnimation(),
            _buildMainContent(auth.isAuthenticated),
            _buildFloatingMenuBackdrop(),
          ],
        ),
        floatingActionButtonLocation: FloatingActionButtonLocation.endFloat,
        floatingActionButton: ThemeFloatingSpeedDialMenu(
          loadingMode: widget.setFloatingSpeedDialToLoadingMode,
          hideFloatingSpeedDialMenu: widget.hideFloatingSpeedDialMenu,
          isDialOpenNotifier: ValueNotifier(false),
        ),
      ),
    );
  }

  LoadingScreen? _handleProtectedRoutes(auth) {
    if (DebugConfig.forceDebugScreen) {
      return null;
    }

    if (!DebugConfig.bypassLoginScreen &&
        AuthConfig.useProtectedRoutes &&
        widget.isProtected &&
        !auth.isAuthenticated) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        context.go(Routes.loginScreen.path);
      });
    }

    if (!auth.isAuthenticated && widget.isProtected) {
      return const LoadingScreen();
    }
    return null;
  }

  void _checkConnectivity(connectivity) {
    if (!connectivity.isConnected && !_connectivityChecked) {
      _connectivityChecked = true;
      _connectivityTimer?.cancel();
      _connectivityTimer = Timer(
          const Duration(
              seconds: ThemeSettings.secondsUntilNoInternetNotification), () {
        if (!connectivity.isConnected) {
          WidgetsBinding.instance.addPostFrameCallback((_) {
            if (ModalRoute.of(context)?.isCurrent == true) {
              _showNoInternetNotification(context);
              _userWentOffline = true;
            }
          });
        }
      });
    } else if (connectivity.isConnected && _userWentOffline) {
      _connectivityTimer?.cancel();
      _connectivityChecked = false;
      _userWentOffline = false;

      WidgetsBinding.instance.addPostFrameCallback((_) {
        if (ModalRoute.of(context)?.isCurrent == true) {
          _showBackToInternetConnectionNotification(context);
        }
      });
    }
  }

  ScrollPhysics getScrollPhysics() {
    switch (ThemeSettings.defaultScrollPhysics) {
      case 'never':
        return const NeverScrollableScrollPhysics();
      case 'always':
        return const AlwaysScrollableScrollPhysics();
      case 'clamp':
        return const ClampingScrollPhysics();
      default:
        return const AlwaysScrollableScrollPhysics();
    }
  }

  LottieAnimationBackground? getLottieAnimation() {
    final bool isDarkMode =
        ref.watch(themeProvider).themeMode == ThemeMode.dark;
    if (isDarkMode && widget.backgroundAnimationDarkMode != null) {
      return widget.backgroundAnimationDarkMode;
    }
    return widget.backgroundAnimation;
  }

  Widget _buildBackgroundAnimation() {
    final animationConfig = getLottieAnimation();
    if (animationConfig != null && animationConfig.active) {
      final screenWidth = MediaQuery.of(context).size.width;
      final screenHeight = MediaQuery.of(context).size.height;
      return Stack(
        children: [
          Positioned(
            left: (screenWidth / 2) +
                animationConfig.x -
                (screenWidth * (animationConfig.width / 100) / 2),
            top: (screenHeight / 2) +
                animationConfig.y -
                (screenWidth * (animationConfig.width / 100) / 2),
            width: screenWidth * (animationConfig.width / 100),
            child: Opacity(
              opacity: animationConfig.opacity,
              child: Lottie.asset(
                animationConfig.animationPath,
              ),
            ),
          ),
          if (animationConfig.blur > 0)
            Positioned.fill(
              child: BackdropFilter(
                filter: ImageFilter.blur(
                    sigmaX: animationConfig.blur, sigmaY: animationConfig.blur),
                child: Container(
                  color: Colors.transparent,
                ),
              ),
            ),
        ],
      );
    }
    return const SizedBox.shrink();
  }

  Widget _buildMainContent(bool isAuthenticated) {
    if (widget.scrollPhysics is NeverScrollableScrollPhysics) {
      return Skeletonizer(
        enabled: !isAuthenticated &&
            widget.isProtected &&
            !DebugConfig.forceDebugScreen &&
            !DebugConfig.bypassLoginScreen,
        child: Padding(
          padding: widget.ignoreGlobalPadding
              ? EdgeInsets.zero
              : (widget.scaffoldPadding ?? ThemeSettings.scaffoldPadding),
          child: widget.body,
        ),
      );
    }

    return SingleChildScrollView(
      physics: widget.scrollPhysics ?? getScrollPhysics(),
      child: Column(
        children: [
          Skeletonizer(
            enabled: !isAuthenticated &&
                widget.isProtected &&
                !DebugConfig.forceDebugScreen &&
                !DebugConfig.bypassLoginScreen,
            child: Padding(
              padding: widget.ignoreGlobalPadding
                  ? EdgeInsets.zero
                  : (widget.scaffoldPadding ?? ThemeSettings.scaffoldPadding),
              child: widget.body,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildFloatingMenuBackdrop() {
    if (!widget.hideFloatingSpeedDialMenu &&
        AppGeneralSettings.useFloatingSpeedDialMenu) {
      return Positioned.fill(
        child: ValueListenableBuilder(
          valueListenable: ValueNotifier(false),
          builder: (context, value, child) {
            return value
                ? BackdropFilter(
                    filter: ImageFilter.blur(sigmaX: 1, sigmaY: 1),
                    child: Container(
                      color: Colors.black.withOpacity(0.1),
                    ),
                  )
                : const SizedBox.shrink();
          },
        ),
      );
    }
    return const SizedBox.shrink();
  }

  void _showNoInternetNotification(BuildContext context) {
    if (ThemeSettings.noInternetNotificationType == 'snackbar') {
      NotificationSnackbar.showSnackBar(
          message: S.of(context).noInternetConnection,
          icon: Icons.wifi_off,
          variant: 'info',
          duration: 'infinite');
    } else if (ThemeSettings.noInternetNotificationType == 'modal') {
      NotificationModal.noInternetConnection(
        context: context,
        onTapConfirm: () {
          setState(() {
            _connectivityChecked = true;
          });
        },
      );
    } else if (ThemeSettings.noInternetNotificationType == 'dialog') {
      showDialog(
        context: context,
        builder: (context) => AlertDialog(
          title: Text(S.of(context).noInternetConnection),
          content: Text(S.of(context).youAreCurrentlyOfflineMessage),
          actions: <Widget>[
            TextButton(
              child: Text(S.of(context).ok),
              onPressed: () {
                context.pop();
              },
            ),
          ],
        ),
      );
    }
  }

  void _showBackToInternetConnectionNotification(BuildContext context) {
    if (ThemeSettings.noInternetNotificationType == 'snackbar') {
      NotificationSnackbar.showSnackBar(
          message: S.of(context).backToInternetConnection,
          icon: Icons.wifi,
          variant: 'success',
          duration: 'long');
    } else if (ThemeSettings.noInternetNotificationType == 'modal') {
      NotificationModal.backToInternetConnection(
        context: context,
        onTapConfirm: () {
          setState(() {
            _connectivityChecked = false; // Allow for future offline checks
          });
        },
      );
    } else if (ThemeSettings.noInternetNotificationType == 'dialog') {
      NotificationSnackbar.showSnackBar(
          message: S.of(context).backToInternetConnection,
          icon: Icons.wifi,
          variant: 'success',
          duration: 'long');
    }
  }
}

///// lib/screens/common/login_screen/login_screen.dart /////
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:sign_in_button/sign_in_button.dart';
import 'package:findatherapistapp/app_settings/auth_config.dart';
import 'package:findatherapistapp/generated/l10n.dart';

import '../../../app_settings/theme_settings.dart';
import '../../../providers/providers_all.dart';
import '../../../routes/routes.dart';
import '../../../utils/validation/is_email_valid.dart';
import '../../../widgets/AppScaffold/app_scaffold.dart';
import '../../../widgets/NotificationModal/notification_modal.dart';
import '../../../widgets/NotificationSnackbar/notification_snackbar.dart';
import '../../../widgets/ThemeInputTextField/theme_input_text_field.dart';

class LoginScreen extends ConsumerStatefulWidget {
  const LoginScreen({super.key});

  @override
  ConsumerState<LoginScreen> createState() => _LoginScreenState();
}

class _LoginScreenState extends ConsumerState<LoginScreen> {
  final TextEditingController _emailController = TextEditingController();
  final TextEditingController _passwordController = TextEditingController();
  final FocusNode _emailFocusNode = FocusNode();
  final FocusNode _passwordFocusNode = FocusNode();
  bool _isEmailValid = true;
  bool _isPasswordValid = true;
  final int minPasswordLength = 6;
  bool _attemptingLogin = false;

  @override
  Widget build(BuildContext context) {
    final bool isDarkMode =
        ref.watch(themeProvider).themeMode == ThemeMode.dark;

    return AppScaffold(
      appBarTitle: S.of(context).loginScreenTitle,
      isProtected: false,
      useSafeArea: false,
      hideFloatingSpeedDialMenu: true,
      backgroundAnimation: ThemeSettings.primaryLottieBackgroundAnimation,
      backgroundAnimationDarkMode:
          ThemeSettings.secondaryLottieBackgroundAnimation,
      body: Stack(
        children: [
          SingleChildScrollView(
            physics: const BouncingScrollPhysics(),
            child: Center(
              child: SizedBox(
                width: 300,
                child: Column(
                  children: <Widget>[
                    const SizedBox(height: 120),
                    Padding(
                      padding: const EdgeInsets.only(bottom: 8),
                      child: Row(
                        crossAxisAlignment: CrossAxisAlignment.end,
                        children: [
                          const Icon(Icons.email_outlined),
                          const SizedBox(width: 5),
                          Text(
                            S.of(context).emailLabel,
                            style: const TextStyle(fontWeight: FontWeight.bold),
                          ),
                        ],
                      ),
                    ),
                    ThemeInputTextField(
                      controller: _emailController,
                      focusNode: _emailFocusNode,
                      hintText: S.of(context).emailHintText,
                      isEmailInput: true,
                      isValid: _isEmailValid,
                      errorText: S.of(context).invalidEmailMessage,
                      onChanged: (value) {
                        if (isEmailValid(value)) {
                          setState(() {
                            _isEmailValid = true;
                          });
                        }
                      },
                    ),
                    const SizedBox(height: 20),
                    Padding(
                      padding: const EdgeInsets.only(bottom: 8.0),
                      child: Row(
                        crossAxisAlignment: CrossAxisAlignment.end,
                        children: [
                          const Icon(Icons.lock_outline),
                          const SizedBox(width: 5),
                          Text(
                            S.of(context).passwordLabel,
                            style: const TextStyle(fontWeight: FontWeight.bold),
                          ),
                        ],
                      ),
                    ),
                    ThemeInputTextField(
                      controller: _passwordController,
                      focusNode: _passwordFocusNode,
                      hintText: S.of(context).passwordHintText,
                      isPasswordInput: true,
                      hidePasswordVisibilityIcon: false,
                      isValid: _isPasswordValid,
                      errorText: S.of(context).invalidPasswordMessage,
                      onChanged: (value) {
                        if (value.isNotEmpty &&
                            value.length >= minPasswordLength) {
                          setState(() {
                            _isPasswordValid = true;
                          });
                        }
                      },
                    ),
                    const SizedBox(height: 32.0),
                    SizedBox(
                      width: 233,
                      child: ElevatedButton(
                        onPressed: _attemptingLogin
                            ? null
                            : () => attemptLoginWithEmailAndPassword(ref),
                        child: Text(S.of(context).loginButton),
                      ),
                    ),
                    Visibility(
                      visible: AuthConfig.allowGoogleSignIn,
                      child: Column(
                        children: [
                          const SizedBox(height: 22.0),
                          SignInButton(Buttons.google,
                              elevation: ThemeSettings.buttonsElevation,
                              padding: const EdgeInsets.all(5.5),
                              clipBehavior: Clip.hardEdge,
                              shape: const RoundedRectangleBorder(
                                  borderRadius:
                                      ThemeSettings.buttonsBorderRadius),
                              text: S.of(context).signInWithGoogleButtonLabel,
                              onPressed: () async {
                            if (AuthConfig.allowGoogleSignIn) {
                              attemptLoginWithGoogle(ref);
                            }
                          }),
                        ],
                      ),
                    ),
                    const Divider(),
                    Row(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        Text(
                          S.of(context).lightMode,
                          style: TextStyle(
                            fontWeight: isDarkMode
                                ? FontWeight.normal
                                : FontWeight.bold,
                          ),
                        ),
                        const Text(
                          ' / ',
                        ),
                        Text(
                          S.of(context).darkMode,
                          style: TextStyle(
                            fontWeight: isDarkMode
                                ? FontWeight.bold
                                : FontWeight.normal,
                          ),
                        ),
                      ],
                    ),
                    const SizedBox(height: 5),
                    Switch(
                      thumbIcon: WidgetStateProperty.all(Icon(
                        isDarkMode ? Icons.dark_mode : Icons.light_mode,
                        color: Colors.white,
                      )),
                      value: isDarkMode,
                      onChanged: (value) {
                        ref.read(themeProvider).toggleTheme(value);
                      },
                    ),
                    const SizedBox(height: 10),
                    Row(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        GestureDetector(
                          onTap: () {
                            ref
                                .read(localeProvider)
                                .setLocale(const Locale('en'));
                          },
                          child: const Text(
                            '🇺🇸',
                            style: TextStyle(fontSize: 30),
                          ),
                        ),
                        const SizedBox(width: 10),
                        const Text('/'),
                        const SizedBox(width: 10),
                        GestureDetector(
                          onTap: () {
                            ref
                                .read(localeProvider)
                                .setLocale(const Locale('es'));
                          },
                          child: const Text(
                            '🇪🇸',
                            style: TextStyle(fontSize: 30),
                          ),
                        ),
                        const SizedBox(width: 10),
                        const Text('/'),
                        const SizedBox(width: 10),
                        GestureDetector(
                          onTap: () {
                            ref
                                .read(localeProvider)
                                .setLocale(const Locale('de'));
                          },
                          child: const Text(
                            '🇩🇪',
                            style: TextStyle(fontSize: 30),
                          ),
                        ),
                      ],
                    ),
                  ],
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }

  void attemptLoginWithEmailAndPassword(WidgetRef ref) async {
    debugPrint('Attempting login...');
    var error = false;
    setState(() {
      _isEmailValid = true;
      _isPasswordValid = true;
    });

    if (_emailController.text.isEmpty || _passwordController.text.isEmpty) {
      List<String> emptyFields = [];
      if (_emailController.text.isEmpty) {
        debugPrint('Please insert a valid email');
        emptyFields.add(S.of(context).email);
        setState(() {
          _isEmailValid = false;
        });
        NotificationSnackbar.showSnackBar(
          message: S.of(context).invalidEmailSnackbarMessage,
          variant: SnackbarVariant.error,
          duration: SnackbarDuration.short,
        );
      }
      if (_passwordController.text.isEmpty) {
        debugPrint('Please insert a valid password');
        emptyFields.add(S.of(context).password);
        setState(() {
          _isPasswordValid = false;
        });
        NotificationSnackbar.showSnackBar(
          message: S.of(context).invalidPasswordSnackbarMessage,
          variant: SnackbarVariant.error,
          duration: SnackbarDuration.short,
        );
        error = true;
      }

      debugPrint('Error: The following fields are empty: $emptyFields');

      NotificationSnackbar.showSnackBar(
        message:
            '${S.of(context).pleaseFillTheFollowingFields} ${emptyFields.join(', ')}.',
        variant: SnackbarVariant.error,
        duration: SnackbarDuration.short,
      );
      error = true;

      NotificationModal.loginFieldsAreEmpty(
          context: context, onTapConfirm: () {}, emptyFields: emptyFields);
    }

    if (_emailController.text.isNotEmpty &&
        !isEmailValid(_emailController.text)) {
      debugPrint('Email is not valid');
      setState(() {
        _isEmailValid = false;
      });
      NotificationSnackbar.showSnackBar(
        message: S.of(context).invalidEmailMessage,
        variant: SnackbarVariant.error,
        duration: SnackbarDuration.short,
      );
      error = true;
    }

    if (_passwordController.text.isNotEmpty &&
        _passwordController.text.length < minPasswordLength) {
      debugPrint('Password is too short. Minimum length: $minPasswordLength');
      setState(() {
        _isPasswordValid = false;
      });
      NotificationSnackbar.showSnackBar(
        message: S.of(context).invalidPasswordTooShortMessage,
        variant: SnackbarVariant.error,
        duration: SnackbarDuration.short,
      );
      error = true;
    }

    if (error) {
      debugPrint('Login aborted.');
      return;
    }

    setState(() {
      _attemptingLogin = true;
    });

    NotificationSnackbar.showSnackBar(
      message: S.of(context).signingInMessage,
      variant: SnackbarVariant.info,
      duration: SnackbarDuration.long,
    );
    try {
      bool userSignedIn = await ref
          .read(authProvider)
          .signInWithEmail(_emailController.text, _passwordController.text);

      if (userSignedIn) {
        void userTappedConfirm() {
          NotificationSnackbar.hideCurrentSnackBar();
          NotificationSnackbar.showSnackBar(
              message: S.of(context).loginSuccessfulMessage,
              variant: SnackbarVariant.success,
              duration: SnackbarDuration.short,
              delay: 1);
          context.go(Routes.welcomeMainScreen.path);
        }

        if (mounted) {
          NotificationModal.successfulModal(
              title: S.of(context).successfulLogin,
              message: S.of(context).successfulLoginRedirectToHomeMessage,
              context: context,
              onTapConfirm: () => userTappedConfirm());
        }
      } else {
        if (mounted) {
          NotificationSnackbar.showSnackBar(
            message: S.of(context).loginErrorMessage,
            variant: SnackbarVariant.error,
            duration: SnackbarDuration.long,
          );
        }
      }
    } catch (error) {
      if (mounted) {
        NotificationSnackbar.showSnackBar(
          message: S.of(context).loginErrorMessage,
          variant: SnackbarVariant.error,
          duration: SnackbarDuration.long,
        );
      }
      if (mounted) {
        NotificationModal.failedLogin(
            context: context,
            onTapConfirm: () {},
            errorMessage: S.of(context).loginErrorMessage);
        debugPrint('Error logging in: ${error.toString()}');
      }
    } finally {
      setState(() {
        _attemptingLogin = false;
      });
      NotificationSnackbar.hideCurrentSnackBar();
    }
  }

  void attemptLoginWithGoogle(WidgetRef ref) async {
    NotificationSnackbar.showSnackBar(
      message: S.of(context).signingInWithGoogleSnackbarMessage,
      variant: SnackbarVariant.info,
      duration: SnackbarDuration.long,
    );
    try {
      bool userSignedIn = await ref.read(authProvider).signInWithGoogle();
      if (userSignedIn) {
        if (mounted) {
          NotificationModal.successfulModal(
            title: S.of(context).successfulLogin,
            message: S.of(context).successfulLoginRedirectToHomeMessage,
            context: context,
            onTapConfirm: () {
              NotificationSnackbar.hideCurrentSnackBar();
              NotificationSnackbar.showSnackBar(
                message: S.of(context).loginSuccessfulMessage,
                variant: SnackbarVariant.success,
                duration: SnackbarDuration.short,
                delay: 1,
              );
              context.go(Routes.welcomeMainScreen.path);
            },
          );
        }
      } else {
        if (mounted) {
          NotificationSnackbar.showSnackBar(
            message: S.of(context).loginErrorMessage,
            variant: SnackbarVariant.error,
            duration: SnackbarDuration.long,
          );
        }
      }
    } on PlatformException catch (error) {
      if (mounted) {
        NotificationSnackbar.showSnackBar(
          message: S.of(context).errorSigningInWithGoogleSnackbarMessage,
          variant: SnackbarVariant.error,
          duration: SnackbarDuration.long,
        );
      }

      debugPrint('Error signing in with Google: ${error.toString()}');
    } catch (error) {
      if (mounted) {
        NotificationSnackbar.showSnackBar(
          message: S.of(context).errorSigningInWithGoogleSnackbarMessage,
          variant: SnackbarVariant.error,
          duration: SnackbarDuration.long,
        );
      }

      debugPrint('Error: ${error.toString()}');
    }
  }
}

///// lib/models/therapist_model.dart /////
import 'package:cloud_firestore/cloud_firestore.dart';

class TherapistModel {
  String id;
  Timestamp createdAt;
  Timestamp updatedAt;
  Aspects aspects;
  Subscription subscription;
  Score score;
  TherapistInfo therapistInfo;
  bool isOnline;

  TherapistModel({
    required this.id,
    required this.createdAt,
    required this.updatedAt,
    required this.aspects,
    required this.subscription,
    required this.score,
    required this.therapistInfo,
    required this.isOnline,
  });

  factory TherapistModel.fromJson(Map<String, dynamic> json, String id) {
    return TherapistModel(
      id: id,
      createdAt: json['createdAt'] as Timestamp,
      updatedAt: json['updatedAt'] as Timestamp,
      aspects: Aspects.fromJson(json['aspects']),
      subscription: Subscription.fromJson(json['subscription']),
      score: Score.fromJson(json['score']),
      therapistInfo: TherapistInfo.fromJson(json['therapistInfo']),
      isOnline: json['isOnline'],
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'createdAt': createdAt,
      'updatedAt': updatedAt,
      'aspects': aspects.toJson(),
      'subscription': subscription.toJson(),
      'score': score.toJson(),
      'therapistInfo': therapistInfo.toJson(),
      'isOnline': isOnline,
    };
  }
}

class Term {
  String term;
  bool public;

  Term({
    required this.term,
    required this.public,
  });

  factory Term.fromJson(Map<String, dynamic> json) {
    return Term(
      term: json['term'],
      public: json['public'],
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'term': term,
      'public': public,
    };
  }
}

class Aspects {
  List<Term> positive;
  List<Term> negative;

  Aspects({
    required this.positive,
    required this.negative,
  });

  factory Aspects.fromJson(Map<String, dynamic> json) {
    return Aspects(
      positive: (json['positive'] as List)
          .map((item) => Term.fromJson(item))
          .toList(),
      negative: (json['negative'] as List)
          .map((item) => Term.fromJson(item))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'positive': positive.map((term) => term.toJson()).toList(),
      'negative': negative.map((term) => term.toJson()).toList(),
    };
  }
}

class Subscription {
  Timestamp endsAt;
  String plan;
  Timestamp startedAt;
  bool autoRenewal;

  Subscription({
    required this.endsAt,
    required this.plan,
    required this.startedAt,
    required this.autoRenewal,
  });

  factory Subscription.fromJson(Map<String, dynamic> json) {
    return Subscription(
      endsAt: json['endsAt'] as Timestamp,
      plan: json['plan'],
      startedAt: json['startedAt'] as Timestamp,
      autoRenewal: json['autoRenewal'],
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'endsAt': endsAt,
      'plan': plan,
      'startedAt': startedAt,
      'autoRenewal': autoRenewal,
    };
  }
}

class Score {
  double rating;
  int amountRatings;

  Score({
    required this.rating,
    required this.amountRatings,
  });

  factory Score.fromJson(Map<String, dynamic> json) {
    return Score(
      rating: (json['rating'] as num).toDouble(),
      amountRatings: json['amountRatings'],
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'rating': rating,
      'amountRatings': amountRatings,
    };
  }
}

class TherapistInfo {
  String intro;
  String publicPresentation;
  String privateNotes;
  Location location;
  String firstName;
  bool userInfoIsVerified;
  String lastName;
  List<String> specializations;
  List<String> spokenLanguages;
  List<ProfessionalCertificate> professionalCertificates;
  ProfilePictureUrl profilePictureUrl;
  MeetingType meetingType;

  TherapistInfo({
    required this.intro,
    required this.publicPresentation,
    required this.privateNotes,
    required this.location,
    required this.firstName,
    required this.userInfoIsVerified,
    required this.lastName,
    required this.specializations,
    required this.spokenLanguages,
    required this.professionalCertificates,
    required this.profilePictureUrl,
    required this.meetingType,
  });

  factory TherapistInfo.fromJson(Map<String, dynamic> json) {
    return TherapistInfo(
      intro: json['intro'],
      publicPresentation: json['publicPresentation'],
      privateNotes: json['privateNotes'],
      location: Location.fromJson(json['location']),
      firstName: json['firstName'],
      userInfoIsVerified: json['userInfoIsVerified'],
      lastName: json['lastName'],
      specializations: List<String>.from(json['specializations']),
      spokenLanguages: List<String>.from(json['spokenLanguages']),
      professionalCertificates: (json['professionalCertificates'] as List)
          .map((i) => ProfessionalCertificate.fromJson(i))
          .toList(),
      profilePictureUrl: ProfilePictureUrl.fromJson(json['profilePictureUrl']),
      meetingType: MeetingType.fromJson(json['meetingType']),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'intro': intro,
      'publicPresentation': publicPresentation,
      'privateNotes': privateNotes,
      'location': location.toJson(),
      'firstName': firstName,
      'userInfoIsVerified': userInfoIsVerified,
      'lastName': lastName,
      'specializations': specializations,
      'spokenLanguages': spokenLanguages,
      'professionalCertificates':
          professionalCertificates.map((i) => i.toJson()).toList(),
      'profilePictureUrl': profilePictureUrl.toJson(),
      'meetingType': meetingType.toJson(),
    };
  }
}

class Location {
  String address;
  String city;
  String country;
  GeoPoint geolocation;
  String stateProvince;
  String zip;

  Location({
    required this.address,
    required this.city,
    required this.country,
    required this.geolocation,
    required this.stateProvince,
    required this.zip,
  });

  factory Location.fromJson(Map<String, dynamic> json) {
    return Location(
      address: json['address'],
      city: json['city'],
      country: json['country'],
      geolocation: json['geolocation'] as GeoPoint,
      stateProvince: json['stateProvince'],
      zip: json['zip'],
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'address': address,
      'city': city,
      'country': country,
      'geolocation': geolocation,
      'stateProvince': stateProvince,
      'zip': zip,
    };
  }
}

class ProfessionalCertificate {
  String institution;
  String photoUrl;
  String title;
  String type;
  bool verified;
  int yearObtained;

  ProfessionalCertificate({
    required this.institution,
    required this.photoUrl,
    required this.title,
    required this.type,
    required this.verified,
    required this.yearObtained,
  });

  factory ProfessionalCertificate.fromJson(Map<String, dynamic> json) {
    return ProfessionalCertificate(
      institution: json['institution'],
      photoUrl: json['photoUrl'],
      title: json['title'],
      type: json['type'],
      verified: json['verified'],
      yearObtained: json['yearObtained'],
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'institution': institution,
      'photoUrl': photoUrl,
      'title': title,
      'type': type,
      'verified': verified,
      'yearObtained': yearObtained,
    };
  }
}

class ProfilePictureUrl {
  String large;
  String small;
  String thumb;

  ProfilePictureUrl({
    required this.large,
    required this.small,
    required this.thumb,
  });

  factory ProfilePictureUrl.fromJson(Map<String, dynamic> json) {
    return ProfilePictureUrl(
      large: json['large'],
      small: json['small'],
      thumb: json['thumb'],
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'large': large,
      'small': small,
      'thumb': thumb,
    };
  }
}

class MeetingType {
  bool presential;
  bool remote;

  MeetingType({
    required this.presential,
    required this.remote,
  });

  factory MeetingType.fromJson(Map<String, dynamic> json) {
    return MeetingType(
      presential: json['presential'],
      remote: json['remote'],
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'presential': presential,
      'remote': remote,
    };
  }
}

///// lib/screens/common/welcome_main_screen/welcome_main_screen.dart /////
import 'package:animate_do/animate_do.dart';
import 'package:findatherapistapp/app_settings/app_info.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:lottie/lottie.dart';
import 'package:skeletonizer/skeletonizer.dart';
import 'package:findatherapistapp/app_settings/app_general_settings.dart';
import 'package:findatherapistapp/widgets/AppScaffold/app_scaffold.dart';

import '../../../generated/l10n.dart';
import '../../../routes/routes.dart';
import '../../../utils/admin/add_current_user_as_therapist.dart';
import '../../../utils/admin/add_current_user_to_database.dart';

class WelcomeMainScreen extends ConsumerStatefulWidget {
  const WelcomeMainScreen({super.key});

  @override
  ConsumerState<WelcomeMainScreen> createState() => _WelcomeMainScreenState();
}

class _WelcomeMainScreenState extends ConsumerState<WelcomeMainScreen> {
  bool useAppBar = AppGeneralSettings.useTopAppBar;
  ValueNotifier<bool> isDialOpen = ValueNotifier(false);
  bool exampleSwitchValue = false;
  static const bool isLoading = false;

  @override
  void initState() {
    super.initState();
  }

  @override
  Widget build(BuildContext context) {
    ///device height
    final double deviceHeight = MediaQuery.of(context).size.height;
    return AppScaffold(
      isProtected: true,
      ignoreGlobalPadding: true,
      appBarTitle: S.of(context).homeScreenTitle,
      body: SizedBox(
        height: deviceHeight - 180,
        child: Column(
          mainAxisAlignment: MainAxisAlignment.end,
          children: <Widget>[
            const SizedBox(
              height: 60,
            ),
            Expanded(
              child: FadeInUp(
                from: 20,
                curve: Curves.decelerate,
                delay: const Duration(milliseconds: 2000),
                duration: const Duration(milliseconds: 900),
                child: Lottie.asset(
                    'lib/assets/lottie_animations/animation2.json',
                    width: 330
                    // Use BoxFit.contain to adjust the size
                    ),
              ),
            ),
            Padding(
              padding: const EdgeInsets.symmetric(horizontal: 27),
              child: Skeletonizer(
                enabled: isLoading,
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    FadeInUp(
                      curve: Curves.decelerate,
                      duration: const Duration(milliseconds: 1000),
                      delay: const Duration(milliseconds: 1500),
                      from: 10,
                      child: Column(
                        children: [
                          Text(
                              '${S.of(context).welcomeToPrefix}${AppInfo.appName}!',
                              style: Theme.of(context).textTheme.headlineSmall),
                          const SizedBox(height: 10),
                          Text(S.of(context).welcomeScreenSubtitleDescription,
                              style: Theme.of(context).textTheme.bodyMedium),
                        ],
                      ),
                    ),
                    const SizedBox(height: 13),
                    FadeInUp(
                      curve: Curves.decelerate,
                      duration: const Duration(milliseconds: 1000),
                      from: 20,
                      child: Column(
                        children: [
                          ElevatedButton(
                              onPressed: () {
                                context.push(Routes.userRequestScreen.path);
                              },
                              style: ElevatedButton.styleFrom(
                                minimumSize: const Size(double.infinity, 47),
                              ),
                              child: Row(
                                mainAxisAlignment: MainAxisAlignment.center,
                                children: [
                                  Text(S.of(context).findYourTherapistButton),
                                ],
                              )),
                          const SizedBox(height: 10),
                          OutlinedButton(
                              onPressed: () {
                                context
                                    .push(Routes.therapistProfileScreen.path);
                                // updateALLTherapistAspects();
                              },
                              style: ElevatedButton.styleFrom(
                                minimumSize: const Size(double.infinity, 47),
                              ),
                              child: Text(
                                  S.of(context).registerAsTherapistButton)),
                        ],
                      ),
                    ),
                  ],
                ),
              ),
            ),
            ElevatedButton(
                onPressed: () {
                  addTherapist();
                  createUser();
                },
                child: Text('Add Therapist and user')),
            const SizedBox(height: 15),
          ],
        ),
      ),
    );
  }
}

///// lib/screens/therapist_area/therapist_personal_profile_screen/therapist_personal_profile_screen.dart /////
import 'dart:io';

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:image_picker/image_picker.dart';
import '../../../../widgets/AppScaffold/app_scaffold.dart';
import '../../../app_settings/theme_settings.dart';
import '../../../providers/providers_all.dart';
import '../../../routes/routes.dart';
import '../../../utils/functions/images_utils.dart';

class TherapistPersonalProfileScreen extends ConsumerStatefulWidget {
  const TherapistPersonalProfileScreen({super.key});

  @override
  ConsumerState<TherapistPersonalProfileScreen> createState() =>
      _TherapistPersonalProfileScreenState();
}

class _TherapistPersonalProfileScreenState
    extends ConsumerState<TherapistPersonalProfileScreen>
    with SingleTickerProviderStateMixin {
  final _formKey = GlobalKey<FormState>();

  final TextEditingController _firstNameController = TextEditingController();
  final TextEditingController _lastNameController = TextEditingController();
  final TextEditingController _birthdayController = TextEditingController();
  final TextEditingController _emailController = TextEditingController();
  final TextEditingController _phoneController = TextEditingController();
  final TextEditingController _bioController = TextEditingController();
  final TextEditingController _publicPresentationController =
      TextEditingController();
  final TextEditingController _privateNotesController = TextEditingController();
  final TextEditingController _addressController = TextEditingController();
  final TextEditingController _cityController = TextEditingController();
  final TextEditingController _countryController = TextEditingController();
  final TextEditingController _stateProvinceController =
      TextEditingController();
  final TextEditingController _zipController = TextEditingController();
  final TextEditingController _profilePictureUrlController =
      TextEditingController();
  List<String> _specializations = [];
  List<String> _spokenLanguages = [];
  bool _presential = false;
  bool _remote = false;
  File? _selectedImage;

  late TabController _tabController;

  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 2, vsync: this);
  }

  @override
  void dispose() {
    _tabController.dispose();
    _firstNameController.dispose();
    _lastNameController.dispose();
    _birthdayController.dispose();
    _emailController.dispose();
    _phoneController.dispose();
    _bioController.dispose();
    _publicPresentationController.dispose();
    _privateNotesController.dispose();
    _addressController.dispose();
    _cityController.dispose();
    _countryController.dispose();
    _stateProvinceController.dispose();
    _zipController.dispose();
    _profilePictureUrlController.dispose();
    super.dispose();
  }

  Future<void> _pickImageFromGallery() async {
    final imageFile = await pickImage(
      ImageSource.gallery,
    );

    if (imageFile != null) {
      setState(() {
        _selectedImage = imageFile;
      });
      final downloadUrl = await uploadImageToFirebase(_selectedImage!);

      if (downloadUrl != null) {
        setState(() {
          _profilePictureUrlController.text = downloadUrl;
        });

        // Aquí puedes actualizar el perfil del terapeuta con la URL de la imagen subida
        debugPrint('Image uploaded: $downloadUrl');
      }
    }
  }

  Future<void> _pickImageFromCamera() async {
    final imageFile = await pickImage(ImageSource.camera);

    if (imageFile != null) {
      setState(() {
        _selectedImage = imageFile;
      });
      final downloadUrl = await uploadImageToFirebase(_selectedImage!);

      if (downloadUrl != null) {
        setState(() {
          _profilePictureUrlController.text = downloadUrl;
        });

        // Aquí puedes actualizar el perfil del terapeuta con la URL de la imagen subida
        debugPrint('Image uploaded: $downloadUrl');
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final bool isDarkMode =
        ref.watch(themeProvider).themeMode == ThemeMode.dark;

    final labelTextStyle = Theme.of(context).textTheme.titleMedium?.copyWith(
          fontSize: 15,
        );

    return AppScaffold(
      ignoreGlobalPadding: true,
      backButton: () {
        if (context.canPop()) {
          context.pop();
        } else {
          context.go(Routes.welcomeMainScreen.path);
        }
      },
      hideFloatingSpeedDialMenu: true,
      scrollPhysics: const NeverScrollableScrollPhysics(),
      appBarTitle: "Your Therapist Profile",
      useTopAppBar: true,
      actions: [
        IconButton(
          icon: Icon(Icons.settings),
          onPressed: () {
            context.push(Routes.settingsScreen.path);
          },
        ),
      ],
      isProtected: false,
      body: NestedScrollView(
        headerSliverBuilder: (context, innerBoxIsScrolled) => [
          SliverAppBar(
            backgroundColor: isDarkMode
                ? ThemeSettings.scaffoldBackgroundColor.darkModePrimary
                : ThemeSettings.scaffoldBackgroundColor.lightModePrimary,
            surfaceTintColor: Color(0xFF4B4B4B),
            leading: Container(),
            expandedHeight: 220.0,
            floating: true,
            pinned: true,
            flexibleSpace: LayoutBuilder(
              builder: (BuildContext context, BoxConstraints constraints) {
                double top = constraints.biggest.height;
                return FlexibleSpaceBar(
                  centerTitle: true,
                  background: Column(
                    children: [
                      const SizedBox(height: 20),
                      Stack(
                        fit: StackFit.loose,
                        alignment: Alignment.topCenter,
                        clipBehavior: Clip.none,
                        children: [
                          ClipOval(
                            child: Material(
                              color: Colors.transparent,
                              child: InkWell(
                                splashColor: Colors.black.withAlpha(30),
                                onTap: () {
                                  // Acción al presionar la imagen de perfil
                                },
                                child: InkWell(
                                  splashColor: Colors.black.withAlpha(30),
                                  onTap: _pickImageFromGallery,
                                  child: AnimatedContainer(
                                    clipBehavior: Clip.hardEdge,
                                    duration: Duration(milliseconds: 100),
                                    margin: EdgeInsets.only(
                                      top: top > 160.0 ? 0.0 : 17.0,
                                    ),
                                    width: top > 160.0 ? 140.0 : 80.0,
                                    height: top > 160.0 ? 140.0 : 80.0,
                                    decoration: BoxDecoration(
                                      boxShadow: [
                                        BoxShadow(
                                          color: Colors.grey.withOpacity(0.1),
                                          blurRadius: 1,
                                          offset: const Offset(0, 1),
                                        ),
                                      ],
                                      shape: BoxShape.circle,
                                      border: Border.all(
                                        color: Colors.white,
                                        width: 4,
                                      ),
                                    ),
                                    child: Ink(
                                      decoration: const BoxDecoration(
                                        shape: BoxShape.circle,
                                        image: DecorationImage(
                                          image: AssetImage(
                                            'lib/assets/placeholders/default_profile_picture.jpg',
                                          ),
                                          fit: BoxFit.cover,
                                        ),
                                      ),
                                    ),
                                  ),
                                ),
                              ),
                            ),
                          ),
                          if (top > 160.0)
                            Positioned(
                              right: -4,
                              top: 10,
                              child: Container(
                                padding: const EdgeInsets.all(0),
                                width: 35,
                                height: 35,
                                decoration: const BoxDecoration(
                                  border: Border.fromBorderSide(BorderSide(
                                    color: Colors.black26,
                                    width: 3,
                                  )),
                                  color: Colors.white,
                                  shape: BoxShape.circle,
                                ),
                                child: Center(
                                  child: IconButton(
                                    padding: EdgeInsets.zero,
                                    icon: const Icon(
                                      Icons.camera_alt,
                                      size: 19,
                                    ),
                                    color: Colors.black54,
                                    onPressed:
                                        _pickImageFromCamera, // Llamar a la nueva función aquí
                                  ),
                                ),
                              ),
                            ),
                        ],
                      ),
                    ],
                  ),
                );
              },
            ),
            bottom: TabBar(
              overlayColor: WidgetStateProperty.all<Color>(Colors.transparent),
              splashFactory: null,
              controller: _tabController,
              tabAlignment: TabAlignment.center,
              dividerColor: Colors.transparent,
              labelStyle: Theme.of(context).textTheme.titleMedium,
              labelPadding:
                  const EdgeInsets.symmetric(vertical: 0, horizontal: 12),
              tabs: const [
                Tab(
                  text: 'Personal Info',
                ),
                Tab(text: 'About me'),
              ],
            ),
          ),
        ],
        body: TabBarView(
          controller: _tabController,
          children: [
            // Personal Info Tab
            SingleChildScrollView(
              physics: const ClampingScrollPhysics(),
              child: Padding(
                padding: const EdgeInsets.symmetric(
                  horizontal: 18.0,
                  vertical: 16.0,
                ),
                child: Form(
                  key: _formKey,
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      const SizedBox(height: 16),
                      Text(
                        'First Name',
                        style: labelTextStyle,
                      ),
                      const SizedBox(height: 8),
                      TextFormField(
                        controller: _firstNameController,
                        validator: (value) {
                          if (value == null || value.isEmpty) {
                            return 'Please enter your full name';
                          }
                          return null;
                        },
                      ),
                      const SizedBox(height: 10),
                      Text(
                        'Last Name',
                        style: labelTextStyle,
                      ),
                      const SizedBox(height: 8),
                      TextFormField(
                        controller: _lastNameController,
                        validator: (value) {
                          if (value == null || value.isEmpty) {
                            return 'Please enter your full name';
                          }
                          return null;
                        },
                      ),
                      const SizedBox(height: 10),
                      Text(
                        'Birthday',
                        style: labelTextStyle,
                      ),
                      const SizedBox(height: 8),
                      TextFormField(
                        controller: _birthdayController,
                        decoration: const InputDecoration(
                          suffixIcon: Icon(Icons.calendar_today),
                        ),
                        readOnly: true,
                        onTap: () {
                          // Acción para seleccionar la fecha
                        },
                        validator: (value) {
                          if (value == null || value.isEmpty) {
                            return 'Please enter your birthday';
                          }
                          return null;
                        },
                      ),
                      const SizedBox(height: 10),
                      Text(
                        'Email',
                        style: labelTextStyle,
                      ),
                      const SizedBox(height: 8),
                      TextFormField(
                        controller: _emailController,
                        keyboardType: TextInputType.emailAddress,
                        validator: (value) {
                          if (value == null || value.isEmpty) {
                            return 'Please enter your email';
                          }
                          return null;
                        },
                      ),
                      const SizedBox(height: 10),
                      Text(
                        'Phone',
                        style: labelTextStyle,
                      ),
                      const SizedBox(height: 8),
                      TextFormField(
                        controller: _phoneController,
                        decoration: const InputDecoration(
                          suffixIcon: Icon(Icons.arrow_drop_down),
                        ),
                        keyboardType: TextInputType.phone,
                        validator: (value) {
                          if (value == null || value.isEmpty) {
                            return 'Please enter your phone number';
                          }
                          return null;
                        },
                      ),
                      const SizedBox(height: 10),
                      Text(
                        'Address',
                        style: labelTextStyle,
                      ),
                      const SizedBox(height: 8),
                      TextFormField(
                        controller: _addressController,
                      ),
                      const SizedBox(height: 10),
                      Text('City', style: labelTextStyle),
                      const SizedBox(height: 8),
                      TextFormField(
                        controller: _cityController,
                      ),
                      const SizedBox(height: 10),
                      Text(
                        'Country',
                        style: labelTextStyle,
                      ),
                      const SizedBox(height: 8),
                      TextFormField(
                        controller: _countryController,
                      ),
                      const SizedBox(height: 10),
                      Text(
                        'State/Province',
                        style: labelTextStyle,
                      ),
                      const SizedBox(height: 8),
                      TextFormField(
                        controller: _stateProvinceController,
                      ),
                      const SizedBox(height: 10),
                      Text(
                        'Zip Code',
                        style: labelTextStyle,
                      ),
                      const SizedBox(height: 8),
                      TextFormField(
                        controller: _zipController,
                      ),
                      const SizedBox(height: 10),
                      Text(
                        'Add Specialization/s',
                        style: labelTextStyle,
                      ),
                      const SizedBox(height: 8),
                      TextFormField(
                        decoration: InputDecoration(
                          suffixIcon: IconButton(
                            icon: const Icon(Icons.add),
                            onPressed: () {
                              // Acción para agregar especialización
                            },
                          ),
                        ),
                      ),
                      const SizedBox(height: 10),
                      Text(
                        'Add Spoken Language/s',
                        style: labelTextStyle,
                      ),
                      const SizedBox(height: 8),
                      TextFormField(
                        decoration: InputDecoration(
                          suffixIcon: IconButton(
                            icon: Icon(Icons.add),
                            onPressed: () {
                              // Acción para agregar idioma hablado
                            },
                          ),
                        ),
                      ),
                      const SizedBox(height: 16),
                      Row(
                        children: [
                          Checkbox(
                            value: _presential,
                            onChanged: (bool? value) {
                              setState(() {
                                _presential = value ?? false;
                              });
                            },
                          ),
                          Text(
                            'Presential',
                            style: Theme.of(context).textTheme.titleMedium,
                          ),
                        ],
                      ),
                      Row(
                        children: [
                          Checkbox(
                            value: _remote,
                            onChanged: (bool? value) {
                              setState(() {
                                _remote = value ?? false;
                              });
                            },
                          ),
                          Text(
                            'Remote',
                            style: Theme.of(context).textTheme.titleMedium,
                          ),
                        ],
                      ),
                    ],
                  ),
                ),
              ),
            ),
            // About me Tab
            SingleChildScrollView(
              physics: ClampingScrollPhysics(),
              child: Padding(
                padding: const EdgeInsets.all(16.0),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    SizedBox(height: 16),
                    Text(
                      'Intro',
                      style: labelTextStyle,
                    ),
                    SizedBox(height: 8),
                    TextFormField(
                      controller: _bioController,
                      maxLines: 3,
                      validator: (value) {
                        if (value == null || value.isEmpty) {
                          return 'Please enter your intro';
                        }
                        return null;
                      },
                    ),
                    const SizedBox(height: 10),
                    Text(
                      'Public Presentation',
                      style: labelTextStyle,
                    ),
                    SizedBox(height: 8),
                    TextFormField(
                      controller: _publicPresentationController,
                      maxLines: 8,
                      validator: (value) {
                        if (value == null || value.isEmpty) {
                          return 'Please enter your public presentation';
                        }
                        return null;
                      },
                    ),
                    const SizedBox(height: 10),
                    Text(
                      'Private Notes',
                      style: labelTextStyle,
                    ),
                    SizedBox(height: 8),
                    TextFormField(
                      controller: _privateNotesController,
                      maxLines: 6,
                    ),
                  ],
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }
}

