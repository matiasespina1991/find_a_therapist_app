.
├── README.md
├── _combined.txt
├── analysis_options.yaml
├── concatenate_dart_files.sh
├── firebase-debug.log
├── firebase.json
├── lib
│   ├── _bin
│   │   ├── _demo_widgets_screen.dart
│   │   └── config.dart
│   ├── _mock_data
│   │   └── _mock_therapists.dart
│   ├── app_settings
│   │   ├── app_general_settings.dart
│   │   ├── app_info.dart
│   │   ├── auth_config.dart
│   │   ├── env_settings.dart
│   │   ├── language_settings.dart
│   │   └── theme_settings.dart
│   ├── assets
│   │   ├── app_icons
│   │   │   ├── lupe1.png
│   │   │   └── lupe2.webp
│   │   ├── icons
│   │   │   ├── gold-plan-badge.png
│   │   │   └── verified-badge.png
│   │   ├── images
│   │   └── lottie_animations
│   │       ├── animation.json
│   │       ├── animation10.json
│   │       ├── animation11.json
│   │       ├── animation2.json
│   │       ├── animation3.json
│   │       ├── animation4.json
│   │       ├── animation5.json
│   │       ├── animation6.json
│   │       ├── animation7.json
│   │       ├── animation8.json
│   │       └── animation9.json
│   ├── firebase_options.dart
│   ├── generated
│   │   ├── intl
│   │   │   ├── messages_all.dart
│   │   │   ├── messages_de.dart
│   │   │   ├── messages_en.dart
│   │   │   └── messages_es.dart
│   │   └── l10n.dart
│   ├── globals.dart
│   ├── l10n
│   │   ├── intl_de.arb
│   │   ├── intl_en.arb
│   │   └── intl_es.arb
│   ├── main.dart
│   ├── models
│   │   ├── current_user_data.dart
│   │   ├── gemini_tags_response_model.dart
│   │   ├── general_models.dart
│   │   ├── term_index_model.dart
│   │   ├── theme_models.dart
│   │   └── therapist_model.dart
│   ├── providers
│   │   ├── auth_provider.dart
│   │   ├── locale_provider.dart
│   │   ├── providers_all.dart
│   │   └── theme_provider.dart
│   ├── routes
│   │   └── routes.dart
│   ├── screens
│   │   ├── _example_screen.dart
│   │   ├── admin
│   │   │   └── debug_screen
│   │   ├── common
│   │   │   ├── home_screen
│   │   │   ├── loading_screen
│   │   │   ├── login_screen
│   │   │   ├── not_found_screen
│   │   │   ├── settings_screen
│   │   │   └── therapist_public_profile_screen
│   │   ├── therapist_area
│   │   │   └── therapist_profile_screen.dart
│   │   └── user_area
│   │       ├── user_profile_screen
│   │       └── user_request_screen
│   ├── services
│   │   ├── connectivity_service.dart
│   │   ├── error_reporting_service.dart
│   │   ├── firestore_service.dart
│   │   ├── gemini_service.dart
│   │   └── speech_to_text_service.dart
│   ├── theme
│   │   └── main_theme
│   │       ├── buttons_theme.dart
│   │       ├── chip_theme.dart
│   │       ├── input_theme.dart
│   │       └── main_theme.dart
│   ├── utils
│   │   ├── admin
│   │   │   ├── find_best_therapist_by_aspects.dart
│   │   │   ├── log_all_terms.dart
│   │   │   ├── log_all_therapists.dart
│   │   │   ├── to_capital_case.dart
│   │   │   ├── update_all_therapists_aspects.dart
│   │   │   └── update_terms_index_from_all_therapist.dart
│   │   ├── debug
│   │   │   ├── error_code_to_text.dart
│   │   │   ├── log_configurations.dart
│   │   │   └── notify_that_app_is_runing_in_debug_mode.dart
│   │   ├── ui
│   │   │   └── is_dark_mode.dart
│   │   └── validation
│   │       └── is_email_valid.dart
│   └── widgets
│       ├── AppScaffold
│       │   └── app_scaffold.dart
│       ├── LoadingCircle
│       │   └── loading_circle.dart
│       ├── NotificationModal
│       │   └── notification_modal.dart
│       ├── NotificationSnackbar
│       │   └── notification_snackbar.dart
│       ├── Skeletons
│       │   └── SkeletonTherapistCard
│       ├── ThemeAppBar
│       │   └── template_app_bar.dart
│       ├── ThemeFloatingSpeedDialMenu
│       │   └── theme_floating_speed_dial_menu.dart
│       ├── ThemeInputTextField
│       │   └── theme_input_text_field.dart
│       └── TherapistListCard
│           └── therapist_list_card.dart
├── pubspec.lock
├── pubspec.yaml
├── rename_imports.sh
└── template_app.iml

49 directories, 86 files
///// pubspec.yaml /////
name: findatherapistapp
description: "An app to easily find the perfect therapist."

publish_to: 'none' # Remove this line if you wish to publish to pub.dev

version: 1.0.0+1

environment:
  sdk: '>=3.2.6 <4.0.0'

dependencies:
  flutter:
    sdk: flutter
  flutter_localizations:
    sdk: flutter

  # Cupertino Icons is a Flutter plugin for using Cupertino icons in a Flutter app. (Example of use: Icon(CupertinoIcons.share))
  cupertino_icons: ^1.0.8
  # Riverpod is a Flutter plugin for managing state in a Flutter app.
  flutter_riverpod: ^2.5.1
  # Flutter Secure Storage is a Flutter plugin for storing data securely on the device.
  flutter_secure_storage: ^9.2.2
  # Google Fonts is a Flutter plugin for using Google Fonts in a Flutter app.
  google_fonts: ^6.2.1
  # Fluttertoast is a Flutter plugin for showing toast messages in a Flutter app.
  fluttertoast: ^8.2.6
  # Google Sign In is a Flutter plugin for signing with Google. It is a wrapper around the native Google Sign In libraries.
  google_sign_in: ^6.2.1
  # Sign In Button is a Flutter plugin for creating sign-in buttons in a Flutter app.
  sign_in_button: ^3.2.0
  # Go Router is a Flutter plugin for routing in a Flutter app.
  go_router: ^14.2.0
  # Google Generative AI is a Flutter plugin for using Google Generative AI in a Flutter app.
  google_generative_ai: ^0.4.3
  # Speech to Text is a Flutter plugin for converting speech to text in a Flutter app.
  speech_to_text: ^6.6.0
  # Country Picker is a Flutter plugin for selecting countries in a Flutter app.
  country_picker: ^2.0.26


#  # -----------------  GENERAL PACKAGES  -----------------
#  # Url Launcher is a Flutter plugin for launching a URL in the mobile platform. Supports iOS and Android.
#  url_launcher: ^6.3.0
#  # Cached network image is a Flutter library to show images from the internet and keep them in the cache directory.
  cached_network_image: ^3.3.1
#  # Google Fonts is a Flutter plugin for using Google Fonts in a Flutter app.
#  google_fonts: ^6.2.1
#  # Flutter Email Validator is a Flutter plugin for validating email addresses in a Flutter app.
#  email_validator: ^2.1.17
#  # Permission Handler is a Flutter plugin for requesting permissions in a Flutter app.
#  permission_handler: ^11.3.1
#  # Image Picker is a plugin for selecting images from the Android and iOS image library, and taking new pictures with the camera:
#  image_picker: ^1.1.2
  # Skeletonizer is a Flutter plugin for creating skeleton loading animations in a Flutter app.
  skeletonizer: ^1.3.0

  # Device Info Plus is a Flutter plugin for getting information about the device the app is running on.
  device_info_plus: ^10.1.0
  # Package Info Plus is a Flutter plugin for getting information about the package the app is running on.
  package_info_plus: ^8.0.0
#  # HTTP is a Flutter plugin for performing HTTP requests. It is a wrapper around the Dart http package.
#  http: ^1.2.1
#  # Webview is a Flutter plugin for rendering web content in a Flutter widget.
#  webview_flutter: ^4.8.0
#  # Share Plus is a Flutter plugin for sharing content (Links to the app, text, emails, files, etc.) from a Flutter app to other apps.
#  share_plus: ^9.0.0
#  # Add 2 Calendar is a Flutter plugin for adding events to the calendar in a Flutter app.
#  add_2_calendar: ^3.0.1
#  # Geo Locator is a Flutter plugin for getting the location of the device in a Flutter app.
#  geolocator: ^12.0.0
#  # Map Launcher is a Flutter plugin for launching maps in a Flutter app.
#  map_launcher: ^2.0.1
#  # Google Maps Flutter is a Flutter plugin for embedding Google Maps in a Flutter app.
#  google_maps_flutter: ^2.7.0
  # Connectivity Plus is a Flutter plugin for getting information about the network connectivity in a Flutter app.
  connectivity_plus: ^6.0.3
#  # Expandable is a Flutter plugin for creating expandable widgets in a Flutter app.
#  expandable: ^5.0.1
#  # Photo View is a Flutter plugin for showing photos in a full-screen view with zooming and panning gestures.
#  photo_view: ^0.15.0
#  # Percent Indicator is a Flutter plugin for showing percentage indicators in a Flutter app.
#  percent_indicator: ^3.0.1

#  # -----------------  WIDGET DESIGN PACKAGES  -----------------
  # Flutter Speed Dial is a Flutter plugin for creating a speed dial menu widget in a Flutter app.
  flutter_speed_dial: ^7.0.0
#  # Badges is a Flutter plugin for creating fancy animated badges in a Flutter app.
  badges: ^3.1.2
#  # Flutter Native Splash is a Flutter plugin for creating a splash screen in a Flutter app.
#  flutter_native_splash: ^2.4.0
#  # Another Flushbar is a Flutter plugin for creating custom snackbars in a Flutter app.
#  another_flushbar: ^1.12.30
#  # Awesome Dialog is a Flutter plugin for creating awesome dialogs in a Flutter app.
#  awesome_dialog: ^3.2.1
#  # Flutter Staggered Grid View is a Flutter plugin for creating staggered grid views in a Flutter app.
#  flutter_staggered_grid_view: ^0.7.0
#  # Animated Toggle Switch is a Flutter plugin for creating animated toggle switches in a Flutter app.
#  animated_toggle_switch: ^1.0.0
#  #Flutter Typeahead is a Flutter input where you can show suggestions to users as they type.
#  flutter_typeahead: ^2.0.0
#  # Mesh Gradient is a Flutter plugin for creating mesh gradients in a Flutter app.
#  mesh_gradient: ^1.3.6

  # -----------------  ANIMATIONS  -----------------
  # Lottie is a Flutter plugin for using Lottie animations in a Flutter app.
  lottie: ^3.1.2

#  # -----------------  FONT PACKAGES  -----------------
#  # Auto Size Text is a Flutter plugin for creating auto-size text in a Flutter app.
#  auto_size_text: ^3.0.0

#  # -----------------  ICONS PACKAGES  -----------------
#  # Material Design Icons is a Flutter plugin for using Material Design icons in a Flutter app. (Example of use: Icon(MdiIcons.add))
#  material_design_icons_flutter: ^7.0.7296
#  # Font Awesome Icons is a Flutter plugin for using Font Awesome icons in a Flutter app. (Example of use: Icon(FontAwesomeIcons.addressBook))
#  font_awesome_flutter: ^10.7.0
#  # Icofont Icons is a Flutter plugin for using Icofont icons in a Flutter app. (Example of use: Icon(IcoFontIcons.addressBook))
#  icofont_flutter: ^1.4.0

#  # -----------------  MEDIA PACKAGES  -----------------
#  # Video Player is a Flutter plugin for playing videos in a Flutter app.
#  video_player: ^2.8.7
#  # Audio Player is a Flutter plugin for playing audio in a Flutter app.
#  audioplayers: ^6.0.0

#  # -----------------  UI THEMES  -----------------
#  # Macos UI is a Flutter plugin for creating MacOS themes in a Flutter app.
#  macos_ui: ^2.0.7
#  # Chicago Theme is a Flutter plugin for creating Chicago themes in a Flutter app.
#  chicago_theme: ^0.4.3-dev
#  # Win32 GUI is a Flutter plugin for creating Win32 GUI themes in a Flutter app.
#  win32_gui 1.1.5

# ----------------- FIREBASE PACKAGES -----------------
#  # Firebase Core is a Flutter plugin to use the Firebase platform services.
  firebase_core: ^3.1.1
#  # Flutter Auth is a Flutter plugin that enables Android and iOS authentication using passwords, phone numbers, and identity providers like Google, Facebook, and Twitter.
  firebase_auth: ^5.1.1
#  # Cloud Firestore is a flexible, scalable database for mobile, web, and server development from Firebase and Google Cloud Platform.
  cloud_firestore: ^5.1.0
  #  # Firebase Database is a Flutter plugin to use the Firebase Realtime Database API and allow storing and syncing data with a NoSQL cloud database.
#  firebase_database: ^11.0.1
#  # Firebase Storage is a Flutter plugin to use the Firebase Cloud Storage API and allow uploading, downloading, and deleting files in the cloud.
#  firebase_storage: ^12.0.1
#  # Firebase Messaging is a Flutter plugin to use the Firebase Cloud Messaging (FCM) API and allow sending push notifications to Android and iOS users.
#  firebase_messaging: ^15.0.1
#  # Firebase In-App Messaging is a Flutter plugin to use the Firebase In-App Messaging API and allow sending in-app messages to Android and iOS users.
#  firebase_in_app_messaging: ^0.8.0+1
#  # Firebase Crashlytics is a Flutter plugin to use the Firebase Crashlytics API and allow sending crash reports to Firebase.
#  firebase_crashlytics: ^4.0.1
#  # Firebase Analytics is a Flutter plugin to use the Firebase Analytics API and allow sending events to Google Analytics.
#  firebase_analytics: ^11.0.1
#  # Firebase Performance Monitoring is a Flutter plugin to use the Firebase Performance Monitoring API and allow sending performance data to Firebase.
#  firebase_performance: ^0.10.0+1
#  # Firebase Remote Config is a Flutter plugin to use the Firebase Remote Config API and allow fetching remote configuration values from Firebase.
#  firebase_remote_config: ^5.0.1

  intl: any
  flutter_localized_locales: ^2.0.5
  expandable: ^5.0.1
  google_mlkit_translation: ^0.11.0

dev_dependencies:
  flutter_test:
    sdk: flutter
  flutter_lints: ^4.0.0
  intl_utils: ^2.8.7
  flutter_launcher_icons: "^0.13.1"

flutter_launcher_icons:
  android: "launcher_icon"
  ios: true
  image_path: "lib/assets/app_icons/lupe1.png"
  min_sdk_android: 23


flutter:

  uses-material-design: true

  # To add assets to your application, add an assets section, like this:
  # assets:
  #   - images/a_dot_burr.jpeg
  #   - images/a_dot_ham.jpeg

  # To add entire folders of assets to your application, add an assets section, like this:
  assets:
    - lib/assets/lottie_animations/
    - lib/assets/images/
    - lib/assets/icons/


  # fonts:
  #   - family: Schyler
  #     fonts:
  #       - asset: fonts/Schyler-Regular.ttf
  #       - asset: fonts/Schyler-Italic.ttf
  #         style: italic
  #   - family: Trajan Pro
  #     fonts:
  #       - asset: fonts/TrajanPro.ttf
  #       - asset: fonts/TrajanPro_Bold.ttf
  #         weight: 700
  #


///// lib/app_settings/app_general_settings.dart /////
import '../routes/routes.dart';

class AppGeneralSettings {
  static const bool useTopAppBar = false;
  static const bool useFloatingSpeedDialMenu = true;
  static const bool useAppDrawerMenu = false;
  static const String minimumiOSVersion =
      '13.0'; // Set this manually in Xcode & Podfile
  static const String minimumAndroidVersion =
      '23'; // Set this manually in android/app/build.gradle
}

class DebugConfig {
  static const bool debugMode = true;
  static const String debugDatabaseId = 'debug-database';
  static const bool showDebugPrints = false;
  static RouteConfig debugScreen = Routes.debugScreen;
  static const forceDebugScreen =
      true; // If true, the route set in debugScreen will be shown and screen protection will be ignored
  static const bool bypassLoginScreen =
      false; // If true, login screen will be skipped
  // static const bool alwaysAllowNavigation =
  //     true;
}

///// lib/app_settings/app_info.dart /////
class AppInfo {
  static const String appName = 'Find-A-Therapist';
}

///// lib/app_settings/auth_config.dart /////
class AuthConfig {
  static const bool useProtectedRoutes = true;
  static const bool useFirebase = true;
  static const bool allowGoogleSignIn = true;
  //TODO: Add scope functionality:
  static const List<String> googleSignInScopes = ['email'];
  static const bool allowFacebookSignIn = false;
  static const bool allowAppleSignIn = false;
  static const bool allowAnonymousSignIn = false;
  static const bool allowEmailSignIn = false;
}

///// lib/app_settings/language_settings.dart /////
class LanguageSettings {
  static const String appDefaultLanguage = 'es';
  static const bool forceDefaultLanguage = false;
  static const List<String> supportedLocales = ['en', 'es', 'de'];
}

///// lib/app_settings/theme_settings.dart /////
import 'package:flutter/material.dart';
import '../models/general_models.dart';
import '../models/theme_models.dart';

class ThemeSettings {
  static const String defaultThemeMode = 'light';
  static const bool forceDefaultThemeMode = false;
  static const bool useMaterial3 = true;
  static const bool useSafeArea = true;
  static const EdgeInsetsGeometry scaffoldPadding = EdgeInsets.only(
    top: 20,
    bottom: 0,
    left: 17,
    right: 17,
  );
  static const Color seedColor = Colors.blueGrey;
  static const bool forceSeedColor = false;
  static const String defaultScrollPhysics =
      'always'; // 'never', 'always', 'clamp'
  static const bool useFlutterToast = false;
  static const String textInputBorderStyle = 'border'; // 'border' / 'no-border'
  static const bool glassTextInputs = true;
  static const double buttonsElevation = 1.1;
  static const double buttonsHeight = 47;
  static const double buttonsOpacity = 0.9;
  static const String noInternetNotificationType =
      'modal'; // 'snackbar' / 'modal' / 'dialog'
  static const int secondsUntilNoInternetNotification = 5;

  static const LottieAnimationBackground primaryLottieBackgroundAnimation =
      LottieAnimationBackground(
    animationPath: 'lib/assets/lottie_animations/animation9.json',
    width: 200,
    x: 0,
    y: 0,
    blur: 80,
    active: true,
    opacity: 0.8,
  );

  static const LottieAnimationBackground secondaryLottieBackgroundAnimation =
      LottieAnimationBackground(
    animationPath: 'lib/assets/lottie_animations/animation4.json',
    width: 200,
    x: 0,
    y: 390,
    blur: 80,
    active: true,
    opacity: 0.8,
  );

  static const ternaryLottieBackgroundAnimation = LottieAnimationBackground(
    animationPath: 'lib/assets/lottie_animations/animation10.json',
    width: 200,
    x: 0,
    y: 0,
    blur: 50,
    active: true,
    opacity: 0.5,
  );

  static const errorColor = Colors.red;

  static const ThemeColors scaffoldBackgroundColor = ThemeColors(
    lightModePrimary: Color(0xFFEFEFEF),
    darkModePrimary: Color(0xFF121212),
  );

  static const ThemeColors appBarBackgroundColor = ThemeColors(
    lightModePrimary: Colors.blueGrey,
    darkModePrimary: Color(0xFF121212),
  );

  static const ThemeColors floatingSpeedDialBackgroundColor = ThemeColors(
    lightModePrimary: Colors.blueGrey,
    darkModePrimary: Colors.white,
  );

  static const ThemeColors primaryTextColor = ThemeColors(
    lightModePrimary: Colors.black,
    darkModePrimary: Colors.white,
  );

  static const ThemeColors secondaryTextColor = ThemeColors(
    lightModePrimary: Colors.black,
    darkModePrimary: Colors.white,
  );

  static const ThemeColors hintTextColor = ThemeColors(
    lightModePrimary: Colors.grey,
    darkModePrimary: Colors.grey,
  );

  static const ThemeColors cardBackgroundColor = ThemeColors(
    lightModePrimary: Colors.blueGrey,
    darkModePrimary: Colors.white,
  );

  static const ThemeColors primaryContainerBackgroundColor = ThemeColors(
    lightModePrimary: Colors.blueGrey,
    darkModePrimary: Colors.blueGrey,
  );

  static const ThemeColors elevatedButtonBackgroundColor = ThemeColors(
    lightModePrimary: Colors.blueGrey,
    darkModePrimary: Colors.white,
  );

  ///AppBar text & background color
  static const ThemeColors appbarOnBackgroundColor = ThemeColors(
    lightModePrimary: Colors.white,
    darkModePrimary: Colors.white,
  );

  static const ThemeColors elevatedButtonTextColor = ThemeColors(
    lightModePrimary: Colors.white,
    darkModePrimary: Colors.black,
  );

  static const ThemeColors outlinedButtonBackgroundColor = ThemeColors(
    lightModePrimary: Colors.blueGrey,
    darkModePrimary: Colors.blueGrey,
  );

  static const ThemeColors outlinedButtonTextColor = ThemeColors(
    lightModePrimary: Colors.black,
    darkModePrimary: Colors.white,
  );

  static const ThemeColors textButtonTextColor = ThemeColors(
    lightModePrimary: Colors.black,
    darkModePrimary: Colors.white,
  );

  static const BorderRadius buttonsBorderRadius = BorderRadius.all(
    Radius.circular(8),
  );

  static const BorderRadius inputsBorderRadius = BorderRadius.all(
    Radius.circular(8),
  );

  static const BorderRadius cardBorderRadius = BorderRadius.all(
    Radius.circular(8),
  );

  static const double cardVerticalSpacing = 4;

  static const BorderRadius chipBorderRadius = BorderRadius.all(
    Radius.circular(8),
  );

  static const Color snackBarErrorBackgroundColor = errorColor;
  static const Color snackBarErrorTextColor = Colors.white;
  static const Color snackBarSuccessBackgroundColor = Colors.green;
  static const Color snackBarSuccessTextColor = Colors.white;
  static const Color snackBarInfoBackgroundColor = Colors.black;
  static const Color snackBarInfoTextColor = Colors.white;

  static const FontConfig appBarTextStyle = FontConfig(
    name: 'Roboto',
    isGoogleFont: true,
  );

  static const FontConfig primaryTextStyle = FontConfig(
    name: 'Roboto',
    isGoogleFont: true,
  );

  static const FontConfig secondaryTextStyle = FontConfig(
    name: 'Open Sans',
    isGoogleFont: true,
  );

  static const FontConfig tertiaryTextStyle = FontConfig(
    name: 'Lato',
    isGoogleFont: true,
  );

  static const FontConfig snackbarTextStyle = FontConfig(
    name: 'Roboto',
    isGoogleFont: true,
  );

  static const double appBarTitleFontSize = 20;
  static const double bodyLargeFontSize = 16;
  static const double bodyMediumFontSize = 13;
  static const double bodySmallFontSize = 12;
  static const double snackbarFontSize = 14;

  static const TextThemes textThemes = TextThemes(
    primaryFont: primaryTextStyle,
    secondaryFont: secondaryTextStyle,
    tertiaryFont: tertiaryTextStyle,
  );
}

///// lib/theme/main_theme/main_theme.dart /////
import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:findatherapistapp/app_settings/theme_settings.dart';
import 'package:findatherapistapp/theme/main_theme/chip_theme.dart';
import 'package:findatherapistapp/theme/main_theme/input_theme.dart';

import '../../models/theme_models.dart';
import 'buttons_theme.dart';

class MainTheme {
  /// --------------- LIGHT THEME ---------------
  static ThemeData get lightTheme {
    final base = ThemeData.light(useMaterial3: ThemeSettings.useMaterial3);
    return _buildTheme(base, Brightness.light);
  }

  /// --------------- DARK THEME ---------------

  static ThemeData get darkTheme {
    final base = ThemeData.dark(useMaterial3: ThemeSettings.useMaterial3);
    return _buildTheme(base, Brightness.dark);
  }

  static ThemeData _buildTheme(ThemeData base, Brightness brightness) {
    ColorScheme colorScheme;

    if (ThemeSettings.forceSeedColor) {
      colorScheme = ColorScheme.fromSeed(
        seedColor: ThemeSettings.seedColor,
        brightness: brightness,
      );
    } else {
      colorScheme = brightness == Brightness.light
          ? ColorScheme.light(
              // primary: Config.primaryTextColor.lightModePrimary,
              primary: ThemeSettings.primaryTextColor.lightModePrimary,
              // secondary: Config.secondaryTextColor.lightModePrimary,
              surface: ThemeSettings.scaffoldBackgroundColor.lightModePrimary,
              secondary: ThemeSettings.secondaryTextColor.lightModePrimary,

              error: ThemeSettings.errorColor,
              onPrimary: Colors.white,
              onSecondary: Colors.white,
              onSurface: ThemeSettings.primaryTextColor.lightModePrimary,
              onError: Colors.white,
              brightness: brightness,
            )
          : ColorScheme.dark(
              primary: ThemeSettings.primaryTextColor.darkModePrimary,
              onPrimary: Colors.black,
              primaryContainer:
                  ThemeSettings.primaryContainerBackgroundColor.darkModePrimary,
              secondary: ThemeSettings.secondaryTextColor.darkModePrimary,
              error: ThemeSettings.errorColor,
              surface: ThemeSettings.scaffoldBackgroundColor.darkModePrimary,
              onSurface: ThemeSettings.primaryTextColor.darkModePrimary,
              onSecondary: Colors.black,
              onError: Colors.black,
              brightness: brightness,
            );
    }

    return base.copyWith(
      colorScheme: colorScheme,
      scaffoldBackgroundColor: colorScheme.surface,
      hintColor: colorScheme.onSurface,
      sliderTheme: base.sliderTheme.copyWith(
        inactiveTrackColor: colorScheme.onSurface.withOpacity(0.5),
      ),
      textTheme:
          _buildTextTheme(base.textTheme, ThemeSettings.primaryTextStyle),
      appBarTheme: AppBarTheme(
        foregroundColor: colorScheme.onPrimary,
        titleTextStyle: ThemeSettings.appBarTextStyle.isGoogleFont
            ? GoogleFonts.getFont(ThemeSettings.appBarTextStyle.name,
                textStyle: TextStyle(
                    fontSize: ThemeSettings.appBarTitleFontSize,
                    color: colorScheme.onPrimary))
            : TextStyle(
                fontFamily: ThemeSettings.appBarTextStyle.name,
                fontSize: ThemeSettings.appBarTitleFontSize,
                color: colorScheme.onPrimary),
        backgroundColor: ThemeSettings.forceSeedColor
            ? colorScheme.primary
            : (brightness == Brightness.light
                ? ThemeSettings.appBarBackgroundColor.lightModePrimary
                : ThemeSettings.appBarBackgroundColor.darkModePrimary),
      ),
      chipTheme: ChipDecorationTheme.chipTheme(brightness, colorScheme),
      cardTheme: base.cardTheme.copyWith(
          shape: const RoundedRectangleBorder(
            borderRadius: ThemeSettings.cardBorderRadius,
          ),
          surfaceTintColor: brightness == Brightness.light
              ? ThemeSettings.cardBackgroundColor.lightModePrimary
              : ThemeSettings.cardBackgroundColor.darkModePrimary),
      inputDecorationTheme:
          InputTheme.inputDecorationTheme(brightness, colorScheme),
      elevatedButtonTheme:
          ButtonsTheme.elevatedButtonTheme(brightness, colorScheme),
      outlinedButtonTheme:
          ButtonsTheme.outlinedButtonTheme(brightness, colorScheme),
      textButtonTheme: ButtonsTheme.textButtonTheme(brightness, colorScheme),
      dividerTheme: base.dividerTheme.copyWith(
        space: 70,
        color: colorScheme.onSurface.withOpacity(0.2),
        thickness: 1,
        indent: 50,
        endIndent: 50,
      ),
    );
  }

  static TextTheme _buildTextTheme(TextTheme base, FontConfig font) {
    return base.copyWith(
      displayLarge: _applyFont(base.displayLarge, font),
      displayMedium: _applyFont(base.displayMedium, font),
      displaySmall: _applyFont(base.displaySmall, font),
      headlineLarge: _applyFont(base.headlineLarge, font),
      headlineMedium: _applyFont(base.headlineMedium, font),
      headlineSmall: _applyFont(base.headlineSmall, font),
      titleLarge: _applyFont(base.titleLarge, font),
      titleMedium: _applyFont(base.titleMedium, font),
      titleSmall: _applyFont(base.titleSmall, font),
      bodyLarge: _applyFont(
          base.bodyLarge?.copyWith(
            fontSize: ThemeSettings.bodyLargeFontSize,
          ),
          font),
      bodyMedium: _applyFont(
          base.bodyMedium?.copyWith(
            fontSize: ThemeSettings.bodyMediumFontSize,
          ),
          font),
      bodySmall: _applyFont(
          base.bodySmall?.copyWith(
            fontSize: ThemeSettings.bodySmallFontSize,
          ),
          font),
      labelLarge: _applyFont(base.labelLarge, font),
      labelMedium: _applyFont(base.labelMedium, font),
      labelSmall: _applyFont(base.labelSmall, font),
    );
  }

  static TextStyle? _applyFont(TextStyle? style, FontConfig font) {
    if (style == null) return null;
    return font.isGoogleFont
        ? GoogleFonts.getFont(font.name, textStyle: style)
        : style.copyWith(fontFamily: font.name, fontSize: style.fontSize);
  }
}

///// lib/routes/routes.dart /////
import 'package:findatherapistapp/app_settings/app_general_settings.dart';
import 'package:findatherapistapp/screens/admin/debug_screen/debug_screen.dart';
import 'package:findatherapistapp/screens/common/loading_screen/loading_screen.dart';
import 'package:findatherapistapp/screens/common/not_found_screen/not_found_screen.dart';
import 'package:go_router/go_router.dart';
import 'package:flutter/material.dart';

import '../screens/common/home_screen/home_screen.dart';
import '../screens/common/login_screen/login_screen.dart';
import '../screens/common/settings_screen/settings_screen.dart';
import '../screens/common/therapist_public_profile_screen/therapist_public_profile_screen.dart';
import '../screens/therapist_area/therapist_profile_screen.dart';
import '../screens/user_area/user_profile_screen/user_profile_screen.dart';
import '../screens/user_area/user_request_screen/user_request_screen.dart';

class Routes {
  /// COMMON ROUTES

  static RouteConfig loginScreen = RouteConfig(
    path: '/login',
    name: 'Login Screen',
    builder: (context) => const LoginScreen(),
  );

  static RouteConfig homeScreen = RouteConfig(
    path: '/',
    name: 'Home Screen',
    builder: (context) => const HomeScreen(),
  );

  static RouteConfig settingsScreen = RouteConfig(
    path: '/settings-screen',
    name: 'Settings Screen',
    builder: (context) => const SettingsScreen(),
  );

  static RouteConfig notFoundScreen = RouteConfig(
    path: '/404',
    name: '404 Not Found',
    builder: (context) => const NotFoundScreen(),
  );

  static RouteConfig loadingScreen = RouteConfig(
      path: '/loading',
      name: 'Loading',
      builder: (context) => const LoadingScreen());

  /// USER AREA ROUTES

  static RouteConfig userProfileScreen = RouteConfig(
    path: '/user-profile',
    name: 'User Profile Screen',
    builder: (context) => const UserProfileScreen(),
  );

  static RouteConfig userRequestScreen = RouteConfig(
    path: '/user-request',
    name: 'User Request',
    builder: (context) => const UserRequestScreen(),
  );

  /// THERAPIST AREA ROUTES

  static RouteConfig therapistProfileScreen = RouteConfig(
    path: '/therapist-profile',
    name: 'Therapist Profile Screen',
    builder: (context) => const TherapistPersonalProfileScreen(),
  );

  /// ADMIN AREA ROUTES

  static RouteConfig debugScreen = RouteConfig(
    path: '/debug-screen',
    name: 'Debug Screen',
    builder: (context) => const DebugScreen(),
  );

  static List<GoRoute> _generateRoutes() {
    List<RouteConfig> allRoutes = [
      loginScreen,
      homeScreen,
      settingsScreen,
      userProfileScreen,
      userRequestScreen,
      therapistProfileScreen,
      notFoundScreen,
      loadingScreen,
      debugScreen,
    ];
    return allRoutes
        .map((routeConfig) => GoRoute(
              path: routeConfig.path,
              builder: (context, state) => routeConfig.builder(context),
            ))
        .toList();
  }

  static final GoRouter router = GoRouter(
    initialLocation:
        DebugConfig.forceDebugScreen ? DebugConfig.debugScreen.path : null,
    routes: _generateRoutes(),
  );
}

class RouteConfig {
  final String path;
  final Widget Function(BuildContext) builder;
  final String name;

  const RouteConfig({
    required this.path,
    required this.builder,
    required this.name,
  });
}

///// lib/main.dart /////
import 'package:country_picker/country_picker.dart';
import 'package:findatherapistapp/routes/routes.dart';
import 'package:findatherapistapp/screens/admin/debug_screen/_print_all_terms_therapists_screen.dart';
import 'package:findatherapistapp/screens/common/home_screen/home_screen.dart';

import 'package:firebase_core/firebase_core.dart';
import 'package:flutter/material.dart';
import 'package:flutter_localizations/flutter_localizations.dart';
import 'package:flutter_localized_locales/flutter_localized_locales.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:skeletonizer/skeletonizer.dart';
import 'package:findatherapistapp/providers/providers_all.dart';
import 'app_settings/app_general_settings.dart';
import 'app_settings/auth_config.dart';
import 'globals.dart';
import 'app_settings/app_info.dart';
import 'app_settings/language_settings.dart';
import 'app_settings/theme_settings.dart';
import 'theme/main_theme/main_theme.dart';
import 'utils/debug/log_configurations.dart';
import 'generated/l10n.dart';

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await initializeApp();
  logConfigurations();
  runApp(const ProviderScope(child: MyApp()));
}

Future<void> initializeApp() async {
  if (AuthConfig.useFirebase) {
    try {
      await Firebase.initializeApp();
    } catch (e) {
      debugPrint('Error: Firebase initialization failed. $e');

      ///TODO: Show an error screen here or retry the initialization.
    }
  }
}

class MyApp extends ConsumerWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final themeNotifier = ref.watch(themeProvider);
    final localeNotifier = ref.watch(localeProvider);

    return SkeletonizerConfig(
      data: const SkeletonizerConfigData(
          effect: ShimmerEffect(),
          enableSwitchAnimation: true,
          containersColor: ThemeSettings.forceSeedColor
              ? ThemeSettings.seedColor
              : Colors.grey),
      child: MaterialApp.router(
        scaffoldMessengerKey: snackbarKey,
        title: AppInfo.appName,
        theme: MainTheme.lightTheme,
        darkTheme: MainTheme.darkTheme,
        themeMode: themeNotifier.themeMode,
        locale: localeNotifier.locale,
        supportedLocales: LanguageSettings.supportedLocales
            .map((e) => Locale.fromSubtags(languageCode: e))
            .toList(),
        localizationsDelegates: const [
          LocaleNamesLocalizationsDelegate(),
          CountryLocalizations.delegate,
          S.delegate,
          GlobalMaterialLocalizations.delegate,
          GlobalWidgetsLocalizations.delegate,
          GlobalCupertinoLocalizations.delegate,
        ],
        localeResolutionCallback: (locale, supportedLocales) {
          if (LanguageSettings.forceDefaultLanguage) {
            return const Locale(LanguageSettings.appDefaultLanguage);
          }
          if (locale != null) {
            for (var supportedLocale in supportedLocales) {
              if (supportedLocale.languageCode == locale.languageCode) {
                return supportedLocale;
              }
            }
          }
          return supportedLocales.first;
        },
        routerDelegate: Routes.router.routerDelegate,
        routeInformationParser: Routes.router.routeInformationParser,
        routeInformationProvider: Routes.router.routeInformationProvider,
      ),
    );
  }
}

///// lib/providers/providers_all.dart /////
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:findatherapistapp/providers/auth_provider.dart';
import 'package:findatherapistapp/providers/locale_provider.dart';
import 'package:findatherapistapp/providers/theme_provider.dart';

import '../services/connectivity_service.dart';

final authProvider = ChangeNotifierProvider((ref) => AuthorizationProvider());
final themeProvider = ChangeNotifierProvider((ref) => ThemeProvider());
final localeProvider = ChangeNotifierProvider((ref) => LocaleProvider());
final connectivityProvider =
    ChangeNotifierProvider((ref) => ConnectivityService());

final navigationStateProvider = StateProvider<bool>((ref) => false);

///// lib/providers/auth_provider.dart /////
import 'package:flutter/material.dart';
import 'package:flutter_secure_storage/flutter_secure_storage.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:google_sign_in/google_sign_in.dart';
import 'package:findatherapistapp/app_settings/app_general_settings.dart';
import 'package:findatherapistapp/app_settings/auth_config.dart';

class AuthorizationProvider extends ChangeNotifier {
  final FlutterSecureStorage storage = const FlutterSecureStorage();
  final FirebaseAuth? _firebaseAuth =
      AuthConfig.useFirebase ? FirebaseAuth.instance : null;
  final GoogleSignIn _googleSignIn =
      GoogleSignIn(scopes: AuthConfig.googleSignInScopes);
  String? _authToken;
  User? _user;
  bool _isLoading = true;

  AuthorizationProvider() {
    _initializeUser();
  }

  String? get authToken => _authToken;
  User? get user => _user;
  bool get isLoading => _isLoading;

  Future<void> _initializeUser() async {
    if (AuthConfig.useFirebase) {
      _user = _firebaseAuth?.currentUser;
      if (_user != null) {
        _authToken = _user!.uid;
      }
    } else {
      _authToken = await storage.read(key: 'auth_token');
    }

    if (DebugConfig.debugMode || DebugConfig.forceDebugScreen) {
      if (_authToken == null && _user == null) {
        debugPrint('[User is not authenticated.]');
      } else {
        debugPrint('[User is authenticated.]');
      }
    }

    if ((DebugConfig.bypassLoginScreen || DebugConfig.forceDebugScreen) &&
        (_authToken == null && _user == null)) {
      debugPrint('Signing user automatically...');
      GoogleSignInAccount? currentUser = await _googleSignIn.signIn();
      if (currentUser != null) {
        _user = await _handleSignIn(currentUser);
        if (_user != null) {
          _authToken = _user?.uid;
          await setAuthToken(_authToken!);
          notifyListeners();
        }
      }
    }

    _isLoading = false;
    notifyListeners();

    _googleSignIn.onCurrentUserChanged
        .listen((GoogleSignInAccount? account) async {
      if (account != null) {
        _user = await _handleSignIn(account);
        if (_user != null) {
          _authToken = _user?.uid;
          await setAuthToken(_authToken!);
        }
      } else {
        _user = null;
        _authToken = null;
      }
      notifyListeners();
    });

    GoogleSignInAccount? currentUser = await _googleSignIn.signInSilently();
    if (currentUser != null) {
      _user = await _handleSignIn(currentUser);
      if (_user != null) {
        _authToken = _user?.uid;
        await setAuthToken(_authToken!);
        notifyListeners();
      }
    }
  }

  Future<User?> _handleSignIn(GoogleSignInAccount account) async {
    try {
      final GoogleSignInAuthentication googleAuth =
          await account.authentication;
      final AuthCredential credential = GoogleAuthProvider.credential(
        idToken: googleAuth.idToken,
        accessToken: googleAuth.accessToken,
      );

      if (AuthConfig.useFirebase) {
        final UserCredential authResult =
            await _firebaseAuth!.signInWithCredential(credential);
        return authResult.user;
      }
      return null;
    } catch (e) {
      debugPrint('Error during Google sign-in: $e');
      return null;
    }
  }

  Future<void> setAuthToken(String token) async {
    await storage.write(key: 'auth_token', value: token);
    _authToken = token;
    notifyListeners();
  }

  Future<void> clearAuthToken() async {
    await storage.delete(key: 'auth_token');
    _authToken = null;
    _user = null;
    debugPrint('Auth token cleared. User will be logged out.');
    notifyListeners();
  }

  Future<void> signOut(BuildContext context) async {
    if (DebugConfig.bypassLoginScreen) {
      debugPrint(
          'Error: Bypass Login Screen is on. Disable it from AppGeneralSettings.bypassLoginScreen in order to proceed with sign out.');
      return;
    }
    await clearAuthToken();
    if (AuthConfig.useFirebase) {
      await _firebaseAuth?.signOut();
    }

    if (AuthConfig.allowGoogleSignIn) {
      await _googleSignIn.signOut();
    }
  }

  bool get isAuthenticated =>
      !isLoading &&
      (DebugConfig.bypassLoginScreen ||
          (_authToken != null && _authToken!.isNotEmpty));

  Future<bool> signInWithEmail(String email, String password) async {
    bool success = false;
    try {
      debugPrint('Signing in with email/password...');

      if (AuthConfig.useFirebase) {
        final UserCredential authResult = await _firebaseAuth!
            .signInWithEmailAndPassword(email: email, password: password);
        _authToken = authResult.user!.uid;
        _user = authResult.user;
        await setAuthToken(_authToken!);
      } else {
        _authToken = email;
        await setAuthToken(_authToken!);
      }

      notifyListeners();
      success = true;
      debugPrint('User logged in successfully.✅');
      return success;
    } catch (error) {
      debugPrint('Error during email/password Sign In: ${error.toString()}');
      success = false;
      return success;
    }
  }

  Future<bool> signInWithGoogle() async {
    bool success = false;
    if (AuthConfig.allowGoogleSignIn) {
      try {
        debugPrint('Signing in with Google...');

        final GoogleSignInAccount? googleUser = await _googleSignIn.signIn();
        if (googleUser != null) {
          debugPrint('Google Sign In successful.');
          final GoogleSignInAuthentication googleAuth =
              await googleUser.authentication;
          final credential = GoogleAuthProvider.credential(
            accessToken: googleAuth.accessToken,
            idToken: googleAuth.idToken,
          );

          if (AuthConfig.useFirebase) {
            final UserCredential? authResult =
                await _firebaseAuth?.signInWithCredential(credential);
            _authToken = authResult?.user!.uid;
            _user = authResult?.user;
            await setAuthToken(_authToken!);
          } else {
            _authToken = googleAuth.accessToken;
            await setAuthToken(_authToken!);
          }

          notifyListeners();
          success = true;
          debugPrint('User logged in successfully.');
          return success;
        }
      } catch (error) {
        debugPrint(
            'Error trying to signing in user using Google: ${error.toString()}');
        success = false;
        return success;
      }
    }
    return success;
  }
}

///// lib/providers/theme_provider.dart /////
import 'package:flutter/material.dart';
import 'package:flutter_secure_storage/flutter_secure_storage.dart';
import 'package:findatherapistapp/app_settings/theme_settings.dart';

class ThemeProvider extends ChangeNotifier {
  ThemeMode _themeMode = ThemeMode.system;
  final FlutterSecureStorage _storage = const FlutterSecureStorage();

  ThemeProvider() {
    _loadThemeMode();
  }

  ThemeMode get themeMode => _themeMode;

  void toggleTheme(bool isDarkMode) async {
    if (ThemeSettings.forceDefaultThemeMode) {
      debugPrint(
          'Error: Theme mode change forbidden. Forced theme is on. Disable it from ThemeSettings.forceDefaultThemeMode in order to proceed with theme change.');
      return;
    }

    _themeMode = isDarkMode ? ThemeMode.dark : ThemeMode.light;
    notifyListeners();

    String userDefinedTheme = isDarkMode ? 'dark' : 'light';
    await _storage.write(
        key: 'user_defined_theme_mode', value: userDefinedTheme);
  }

  void _loadThemeMode() async {
    if (ThemeSettings.forceDefaultThemeMode) {
      _themeMode = ThemeSettings.defaultThemeMode == 'dark'
          ? ThemeMode.dark
          : ThemeMode.light;
      notifyListeners();
      return;
    }

    String? userDefinedTheme =
        await _storage.read(key: 'user_defined_theme_mode');

    if (userDefinedTheme != null) {
      bool isDarkMode = userDefinedTheme == 'dark';
      _themeMode = isDarkMode ? ThemeMode.dark : ThemeMode.light;
      notifyListeners();
    }
  }
}

///// lib/widgets/AppScaffold/app_scaffold.dart /////
import 'dart:async';
import 'dart:ui';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:lottie/lottie.dart';
import 'package:findatherapistapp/app_settings/app_general_settings.dart';
import 'package:findatherapistapp/app_settings/auth_config.dart';
import 'package:findatherapistapp/providers/providers_all.dart';
import 'package:findatherapistapp/utils/ui/is_dark_mode.dart';
import 'package:findatherapistapp/widgets/NotificationModal/notification_modal.dart';
import 'package:findatherapistapp/widgets/NotificationSnackbar/notification_snackbar.dart';
import 'package:skeletonizer/skeletonizer.dart';
import '../../app_settings/theme_settings.dart';
import '../../generated/l10n.dart';
import '../../models/general_models.dart';
import '../../routes/routes.dart';
import '../../screens/common/loading_screen/loading_screen.dart';
import '../ThemeAppBar/template_app_bar.dart';
import '../ThemeFloatingSpeedDialMenu/theme_floating_speed_dial_menu.dart';

class AppScaffold extends ConsumerStatefulWidget {
  final Widget body;
  final bool hideFloatingSpeedDialMenu;
  final String appBarTitle;
  final bool isProtected;
  final bool? useSafeArea;
  final ScrollPhysics? scrollPhysics;
  final LottieAnimationBackground? backgroundAnimation;
  final LottieAnimationBackground? backgroundAnimationDarkMode;
  final bool useTopAppBar;
  final bool showScreenTitleInAppBar;
  final EdgeInsetsGeometry? scaffoldPadding;
  final bool ignoreGlobalPadding;
  final List<Widget>? actions;
  final bool? centerTitle;
  const AppScaffold(
      {super.key,
      required this.body,
      required this.appBarTitle,
      required this.isProtected,
      this.useSafeArea,
      this.hideFloatingSpeedDialMenu = false,
      this.scrollPhysics,
      this.backgroundAnimation,
      this.backgroundAnimationDarkMode,
      this.useTopAppBar = false,
      this.showScreenTitleInAppBar = true,
      this.scaffoldPadding,
      this.ignoreGlobalPadding = false,
      this.actions,
      this.centerTitle});

  @override
  AppScaffoldState createState() => AppScaffoldState();
}

class AppScaffoldState extends ConsumerState<AppScaffold> {
  bool _connectivityChecked = false;
  bool _userWentOffline = false;
  Timer? _connectivityTimer;

  @override
  void initState() {
    super.initState();

    final String debugRouteName = DebugConfig.debugScreen.name;

    if (DebugConfig.forceDebugScreen && debugRouteName.isNotEmpty) {
      bool navigationAllowed = true;
      // if (DebugConfig.alwaysAllowNavigation) {
      //   navigationAllowed = true;
      // }
      debugPrint(
          '[DebugConfig.forceDebugScreen is set to true. Target screen is: $debugRouteName. Navigation ${navigationAllowed ? 'allowed' : 'is blocked'}.');
    }
  }

  @override
  void dispose() {
    _connectivityTimer?.cancel();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final auth = ref.watch(authProvider);
    final connectivity = ref.watch(connectivityProvider);

    if (auth.isLoading && !auth.isAuthenticated) {
      return const LoadingScreen();
    }

    _handleProtectedRoutes(auth);
    _checkConnectivity(connectivity);

    return SafeArea(
      bottom: widget.useSafeArea ?? ThemeSettings.useSafeArea,
      top: widget.useSafeArea ?? ThemeSettings.useSafeArea,
      child: Scaffold(
        appBar: (AppGeneralSettings.useTopAppBar || widget.useTopAppBar)
            ? ThemeAppBar(
                centerTitle: widget.centerTitle,
                actions: widget.actions,
                title: widget.showScreenTitleInAppBar ? widget.appBarTitle : '',
              )
            : null,
        body: Stack(
          fit: StackFit.expand,
          children: [
            _buildBackgroundAnimation(),
            _buildMainContent(auth.isAuthenticated),
            _buildFloatingMenuBackdrop(),
          ],
        ),
        floatingActionButton: ThemeFloatingSpeedDialMenu(
          hideFloatingSpeedDialMenu: widget.hideFloatingSpeedDialMenu,
          isDialOpenNotifier: ValueNotifier(false),
        ),
      ),
    );
  }

  LoadingScreen? _handleProtectedRoutes(auth) {
    if (DebugConfig.forceDebugScreen) {
      return null;
    }

    if (!DebugConfig.bypassLoginScreen &&
        AuthConfig.useProtectedRoutes &&
        widget.isProtected &&
        !auth.isAuthenticated) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        context.go(Routes.loginScreen.path);
      });
    }

    if (!auth.isAuthenticated && widget.isProtected) {
      return const LoadingScreen();
    }
    return null;
  }

  void _checkConnectivity(connectivity) {
    if (!connectivity.isConnected && !_connectivityChecked) {
      _connectivityChecked = true;
      _connectivityTimer?.cancel();
      _connectivityTimer = Timer(
          const Duration(
              seconds: ThemeSettings.secondsUntilNoInternetNotification), () {
        if (!connectivity.isConnected) {
          WidgetsBinding.instance.addPostFrameCallback((_) {
            if (ModalRoute.of(context)?.isCurrent == true) {
              _showNoInternetNotification(context);
              _userWentOffline = true;
            }
          });
        }
      });
    } else if (connectivity.isConnected && _userWentOffline) {
      _connectivityTimer?.cancel();
      _connectivityChecked = false;
      _userWentOffline = false;

      WidgetsBinding.instance.addPostFrameCallback((_) {
        if (ModalRoute.of(context)?.isCurrent == true) {
          _showBackToInternetConnectionNotification(context);
        }
      });
    }
  }

  ScrollPhysics getScrollPhysics() {
    switch (ThemeSettings.defaultScrollPhysics) {
      case 'never':
        return const NeverScrollableScrollPhysics();
      case 'always':
        return const AlwaysScrollableScrollPhysics();
      case 'clamp':
        return const ClampingScrollPhysics();
      default:
        return const AlwaysScrollableScrollPhysics();
    }
  }

  LottieAnimationBackground? getLottieAnimation() {
    final themeIsDark = isDarkMode(context);
    if (themeIsDark && widget.backgroundAnimationDarkMode != null) {
      return widget.backgroundAnimationDarkMode;
    }
    return widget.backgroundAnimation;
  }

  Widget _buildBackgroundAnimation() {
    final animationConfig = getLottieAnimation();
    if (animationConfig != null && animationConfig.active) {
      final screenWidth = MediaQuery.of(context).size.width;
      final screenHeight = MediaQuery.of(context).size.height;
      return Stack(
        children: [
          Positioned(
            left: (screenWidth / 2) +
                animationConfig.x -
                (screenWidth * (animationConfig.width / 100) / 2),
            top: (screenHeight / 2) +
                animationConfig.y -
                (screenWidth * (animationConfig.width / 100) / 2),
            width: screenWidth * (animationConfig.width / 100),
            child: Opacity(
              opacity: animationConfig.opacity,
              child: Lottie.asset(
                animationConfig.animationPath,
              ),
            ),
          ),
          if (animationConfig.blur > 0)
            Positioned.fill(
              child: BackdropFilter(
                filter: ImageFilter.blur(
                    sigmaX: animationConfig.blur, sigmaY: animationConfig.blur),
                child: Container(
                  color: Colors.transparent,
                ),
              ),
            ),
        ],
      );
    }
    return const SizedBox.shrink();
  }

  Widget _buildMainContent(bool isAuthenticated) {
    if (widget.scrollPhysics is NeverScrollableScrollPhysics) {
      return Skeletonizer(
        enabled: !isAuthenticated &&
            widget.isProtected &&
            !DebugConfig.forceDebugScreen &&
            !DebugConfig.bypassLoginScreen,
        child: Padding(
          padding: widget.ignoreGlobalPadding
              ? EdgeInsets.zero
              : (widget.scaffoldPadding ?? ThemeSettings.scaffoldPadding),
          child: widget.body,
        ),
      );
    }

    return SingleChildScrollView(
      physics: widget.scrollPhysics ?? getScrollPhysics(),
      child: Column(
        children: [
          Skeletonizer(
            enabled: !isAuthenticated &&
                widget.isProtected &&
                !DebugConfig.forceDebugScreen &&
                !DebugConfig.bypassLoginScreen,
            child: Padding(
              padding: ThemeSettings.scaffoldPadding,
              child: widget.body,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildFloatingMenuBackdrop() {
    if (!widget.hideFloatingSpeedDialMenu &&
        AppGeneralSettings.useFloatingSpeedDialMenu) {
      return Positioned.fill(
        child: ValueListenableBuilder(
          valueListenable: ValueNotifier(false),
          builder: (context, value, child) {
            return value
                ? BackdropFilter(
                    filter: ImageFilter.blur(sigmaX: 1, sigmaY: 1),
                    child: Container(
                      color: Colors.black.withOpacity(0.1),
                    ),
                  )
                : const SizedBox.shrink();
          },
        ),
      );
    }
    return const SizedBox.shrink();
  }

  void _showNoInternetNotification(BuildContext context) {
    if (ThemeSettings.noInternetNotificationType == 'snackbar') {
      NotificationSnackbar.showSnackBar(
          message: S.of(context).noInternetConnection,
          icon: Icons.wifi_off,
          variant: 'info',
          duration: 'infinite');
    } else if (ThemeSettings.noInternetNotificationType == 'modal') {
      NotificationModal.noInternetConnection(
        context: context,
        onTapConfirm: () {
          setState(() {
            _connectivityChecked = true;
          });
        },
      );
    } else if (ThemeSettings.noInternetNotificationType == 'dialog') {
      showDialog(
        context: context,
        builder: (context) => AlertDialog(
          title: Text(S.of(context).noInternetConnection),
          content: Text(S.of(context).youAreCurrentlyOfflineMessage),
          actions: <Widget>[
            TextButton(
              child: const Text('OK'),
              onPressed: () {
                context.pop();
              },
            ),
          ],
        ),
      );
    }
  }

  void _showBackToInternetConnectionNotification(BuildContext context) {
    if (ThemeSettings.noInternetNotificationType == 'snackbar') {
      NotificationSnackbar.showSnackBar(
          message: S.of(context).backToInternetConnection,
          icon: Icons.wifi,
          variant: 'success',
          duration: 'long');
    } else if (ThemeSettings.noInternetNotificationType == 'modal') {
      NotificationModal.backToInternetConnection(
        context: context,
        onTapConfirm: () {
          setState(() {
            _connectivityChecked = false; // Allow for future offline checks
          });
        },
      );
    } else if (ThemeSettings.noInternetNotificationType == 'dialog') {
      NotificationSnackbar.showSnackBar(
          message: S.of(context).backToInternetConnection,
          icon: Icons.wifi,
          variant: 'success',
          duration: 'long');
    }
  }
}

///// lib/widgets/TherapistListCard/therapist_list_card.dart /////
import 'package:flutter/material.dart';
import 'package:cached_network_image/cached_network_image.dart';
import 'package:findatherapistapp/app_settings/theme_settings.dart';
import 'package:findatherapistapp/models/therapist_model.dart';

class TherapistListCard extends StatelessWidget {
  final TherapistModel therapist;
  final VoidCallback onTap;

  const TherapistListCard({
    super.key,
    required this.therapist,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    return Container(
      margin: const EdgeInsets.symmetric(
        vertical: ThemeSettings.cardVerticalSpacing,
        horizontal: 6,
      ),
      decoration: BoxDecoration(
        color: Theme.of(context).cardColor,
        boxShadow: [
          if (Theme.of(context).brightness == Brightness.light)
            BoxShadow(
              color: Colors.grey.withOpacity(0.8),
              blurRadius: 5,
              offset: const Offset(1, 2),
            ),
        ],
        borderRadius: ThemeSettings.cardBorderRadius,
        border: BoxBorder.lerp(
          Border.all(
            color: Colors.grey.withOpacity(0.2),
            width: 0.5,
          ),
          Border.all(
            color: Colors.grey.withOpacity(0.2),
            width: 0.5,
          ),
          0.5,
        ),
      ),
      foregroundDecoration: BoxDecoration(
        borderRadius: ThemeSettings.cardBorderRadius,
        gradient: LinearGradient(
          begin: Alignment.topCenter,
          end: Alignment.bottomCenter,
          colors: [
            Colors.transparent,
            ThemeSettings.seedColor.withOpacity(0.01),
          ],
        ),
      ),
      child: Material(
        color: Colors.transparent,
        child: InkWell(
          borderRadius: ThemeSettings.cardBorderRadius,
          onTap: onTap,
          child: Stack(
            children: [
              Padding(
                padding: const EdgeInsets.all(15),
                child: Row(
                  children: [
                    Stack(
                      children: [
                        Container(
                          decoration: BoxDecoration(
                            boxShadow: [
                              BoxShadow(
                                color: Colors.grey.withOpacity(0.4),
                                blurRadius: 1,
                                offset: const Offset(0, 1),
                              ),
                            ],
                            shape: BoxShape.circle,
                            border: Border.all(
                              color: Colors.white,
                              width: 2,
                            ),
                          ),
                          padding: const EdgeInsets.all(2),
                          child: CircleAvatar(
                            radius: 40,
                            backgroundImage: CachedNetworkImageProvider(
                              therapist.therapistInfo.profilePictureUrl.small,
                            ),
                          ),
                        ),
                        if (therapist.isOnline)
                          Positioned(
                            bottom: 1.5,
                            right: 2,
                            child: Card(
                              elevation: 0.5,
                              child: Container(
                                width: 17,
                                height: 17,
                                decoration: BoxDecoration(
                                  shape: BoxShape.circle,
                                  color: therapist.isOnline
                                      ? Colors.green
                                      : Colors.red,
                                  border: Border.all(
                                    color: Colors.white,
                                    width: 3,
                                  ),
                                ),
                              ),
                            ),
                          ),
                      ],
                    ),
                    const SizedBox(width: 20),
                    Expanded(
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Row(
                            children: [
                              Flexible(
                                child: Text(
                                  '${therapist.therapistInfo.firstName} ${therapist.therapistInfo.lastName}',
                                  style: const TextStyle(
                                    fontSize: 17,
                                    fontWeight: FontWeight.bold,
                                  ),
                                ),
                              ),
                              if (therapist.therapistInfo.userInfoIsVerified)
                                Padding(
                                  padding:
                                      const EdgeInsets.symmetric(horizontal: 4),
                                  child: therapist.subscription.plan == 'gold'
                                      ? Image.asset(
                                          'lib/assets/icons/gold-plan-badge.png',
                                          width: 15,
                                        )
                                      : Image.asset(
                                          'lib/assets/icons/verified-badge.png',
                                          width: 15,
                                        ),
                                ),
                            ],
                          ),
                          Text(
                            '${therapist.therapistInfo.location.city}, ${therapist.therapistInfo.location.country}',
                            style: TextStyle(
                              fontSize: 16,
                              color: Colors.grey[500],
                            ),
                          ),
                          Text(
                            therapist.therapistInfo.bio,
                            style: TextStyle(
                              fontSize: 15.5,
                              color: Colors.grey[700],
                            ),
                            maxLines: 3,
                            overflow: TextOverflow.ellipsis,
                          ),
                        ],
                      ),
                    ),
                  ],
                ),
              ),
              Positioned(
                bottom: 7,
                right: 15,
                child: Row(
                  children: [
                    Text('${therapist.score.rating}',
                        style: const TextStyle(
                          fontSize: 15,
                        )),
                    const SizedBox(width: 3),
                    const Icon(
                      Icons.star,
                      color: Colors.amber,
                      size: 18,
                    ),
                  ],
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

///// lib/screens/common/home_screen/home_screen.dart /////
import 'package:findatherapistapp/app_settings/app_info.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:skeletonizer/skeletonizer.dart';
import 'package:findatherapistapp/app_settings/app_general_settings.dart';
import 'package:findatherapistapp/widgets/AppScaffold/app_scaffold.dart';

import '../../../generated/l10n.dart';
import '../../../providers/providers_all.dart';
import '../../../routes/routes.dart';

class HomeScreen extends ConsumerStatefulWidget {
  const HomeScreen({super.key});

  @override
  ConsumerState<HomeScreen> createState() => _HomeScreenState();
}

class _HomeScreenState extends ConsumerState<HomeScreen> {
  bool useAppBar = AppGeneralSettings.useTopAppBar;
  ValueNotifier<bool> isDialOpen = ValueNotifier(false);
  bool exampleSwitchValue = false;
  static const bool isLoading = false;

  @override
  void initState() {
    super.initState();
  }

  @override
  Widget build(BuildContext context) {
    return AppScaffold(
      isProtected: true,
      appBarTitle: S.of(context).homeScreenTitle,
      body: SingleChildScrollView(
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: <Widget>[
            const SizedBox(
              height: 38,
            ),
            Skeletonizer(
              enabled: isLoading,
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text('${S.of(context).welcomeToPrefix}${AppInfo.appName}!',
                      style: Theme.of(context).textTheme.headlineSmall),
                  const SizedBox(height: 10),
                  Text(S.of(context).exampleDescription,
                      style: Theme.of(context).textTheme.bodyMedium),
                  const SizedBox(height: 20),
                  ElevatedButton(
                      onPressed: () {
                        context.push(Routes.userRequestScreen.path);
                      },
                      style: ElevatedButton.styleFrom(
                        minimumSize: const Size(double.infinity, 47),
                      ),
                      child: Text(S.of(context).findYourTherapistButton)),
                  const SizedBox(height: 15),
                  OutlinedButton(
                      onPressed: () {},
                      style: ElevatedButton.styleFrom(
                        minimumSize: const Size(double.infinity, 47),
                      ),
                      child: Text(S.of(context).applyAsTherapistButton)),
                ],
              ),
            ),
            const SizedBox(height: 20),
            Row(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                GestureDetector(
                  onTap: () {
                    ref.read(localeProvider).setLocale(const Locale('en'));
                  },
                  child: const Text(
                    '🇺🇸',
                    style: TextStyle(fontSize: 30),
                  ),
                ),
                const SizedBox(width: 10),
                const Text('/'),
                const SizedBox(width: 10),
                GestureDetector(
                  onTap: () {
                    ref.read(localeProvider).setLocale(const Locale('es'));
                  },
                  child: const Text(
                    '🇪🇸',
                    style: TextStyle(fontSize: 30),
                  ),
                ),
                const SizedBox(width: 10),
                const Text('/'),
                const SizedBox(width: 10),
                GestureDetector(
                  onTap: () {
                    ref.read(localeProvider).setLocale(const Locale('de'));
                  },
                  child: const Text(
                    '🇩🇪',
                    style: TextStyle(fontSize: 30),
                  ),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
}

///// lib/models/therapist_model.dart /////
import 'package:cloud_firestore/cloud_firestore.dart';

class TherapistModel {
  String id;
  Timestamp createdAt;
  Timestamp updatedAt;
  Aspects aspects;
  Subscription subscription;
  Score score;
  TherapistInfo therapistInfo;
  bool isOnline;

  TherapistModel({
    required this.id,
    required this.createdAt,
    required this.updatedAt,
    required this.aspects,
    required this.subscription,
    required this.score,
    required this.therapistInfo,
    required this.isOnline,
  });

  factory TherapistModel.fromJson(Map<String, dynamic> json, String id) {
    return TherapistModel(
      id: id,
      createdAt: json['createdAt'] as Timestamp,
      updatedAt: json['updatedAt'] as Timestamp,
      aspects: Aspects.fromJson(json['aspects']),
      subscription: Subscription.fromJson(json['subscription']),
      score: Score.fromJson(json['score']),
      therapistInfo: TherapistInfo.fromJson(json['therapistInfo']),
      isOnline: json['isOnline'],
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'createdAt': createdAt,
      'updatedAt': updatedAt,
      'aspects': aspects.toJson(),
      'subscription': subscription.toJson(),
      'score': score.toJson(),
      'therapistInfo': therapistInfo.toJson(),
      'isOnline': isOnline,
    };
  }
}

class Aspects {
  List<String> positive;
  List<String> negative;

  Aspects({
    required this.positive,
    required this.negative,
  });

  factory Aspects.fromJson(Map<String, dynamic> json) {
    return Aspects(
      positive: List<String>.from(json['positive']),
      negative: List<String>.from(json['negative']),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'positive': positive,
      'negative': negative,
    };
  }
}

class Subscription {
  Timestamp endsAt;
  String plan;
  Timestamp startedAt;
  bool autoRenewal;

  Subscription({
    required this.endsAt,
    required this.plan,
    required this.startedAt,
    required this.autoRenewal,
  });

  factory Subscription.fromJson(Map<String, dynamic> json) {
    return Subscription(
      endsAt: json['endsAt'] as Timestamp,
      plan: json['plan'],
      startedAt: json['startedAt'] as Timestamp,
      autoRenewal: json['autoRenewal'],
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'endsAt': endsAt,
      'plan': plan,
      'startedAt': startedAt,
      'autoRenewal': autoRenewal,
    };
  }
}

class Score {
  double rating;
  int amountRatings;

  Score({
    required this.rating,
    required this.amountRatings,
  });

  factory Score.fromJson(Map<String, dynamic> json) {
    return Score(
      rating: (json['rating'] as num).toDouble(),
      amountRatings: json['amountRatings'],
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'rating': rating,
      'amountRatings': amountRatings,
    };
  }
}

class TherapistInfo {
  String bio;
  String publicPresentation;
  String privateNotes;
  Location location;
  String firstName;
  bool userInfoIsVerified;
  String lastName;
  List<String> specializations;
  List<String> spokenLanguages;
  List<ProfessionalCertificate> professionalCertificates;
  ProfilePictureUrl profilePictureUrl;

  TherapistInfo({
    required this.bio,
    required this.publicPresentation,
    required this.privateNotes,
    required this.location,
    required this.firstName,
    required this.userInfoIsVerified,
    required this.lastName,
    required this.specializations,
    required this.spokenLanguages,
    required this.professionalCertificates,
    required this.profilePictureUrl,
  });

  factory TherapistInfo.fromJson(Map<String, dynamic> json) {
    return TherapistInfo(
      bio: json['bio'],
      publicPresentation: json['publicPresentation'],
      privateNotes: json['privateNotes'],
      location: Location.fromJson(json['location']),
      firstName: json['firstName'],
      userInfoIsVerified: json['userInfoIsVerified'],
      lastName: json['lastName'],
      specializations: List<String>.from(json['specializations']),
      spokenLanguages: List<String>.from(json['spokenLanguages']),
      professionalCertificates: (json['professionalCertificates'] as List)
          .map((i) => ProfessionalCertificate.fromJson(i))
          .toList(),
      profilePictureUrl: ProfilePictureUrl.fromJson(json['profilePictureUrl']),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'bio': bio,
      'publicPresentation': publicPresentation,
      'privateNotes': privateNotes,
      'location': location.toJson(),
      'firstName': firstName,
      'userInfoIsVerified': userInfoIsVerified,
      'lastName': lastName,
      'specializations': specializations,
      'spokenLanguages': spokenLanguages,
      'professionalCertificates':
          professionalCertificates.map((i) => i.toJson()).toList(),
      'profilePictureUrl': profilePictureUrl.toJson(),
    };
  }
}

class Location {
  String address;
  String city;
  String country;
  GeoPoint geolocation;
  String stateProvince;
  String zip;

  Location({
    required this.address,
    required this.city,
    required this.country,
    required this.geolocation,
    required this.stateProvince,
    required this.zip,
  });

  factory Location.fromJson(Map<String, dynamic> json) {
    return Location(
      address: json['address'],
      city: json['city'],
      country: json['country'],
      geolocation: json['geolocation'] as GeoPoint,
      stateProvince: json['stateProvince'],
      zip: json['zip'],
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'address': address,
      'city': city,
      'country': country,
      'geolocation': geolocation,
      'stateProvince': stateProvince,
      'zip': zip,
    };
  }
}

class ProfessionalCertificate {
  String institution;
  String photoUrl;
  String title;
  String type;
  bool verified;
  int yearObtained;

  ProfessionalCertificate({
    required this.institution,
    required this.photoUrl,
    required this.title,
    required this.type,
    required this.verified,
    required this.yearObtained,
  });

  factory ProfessionalCertificate.fromJson(Map<String, dynamic> json) {
    return ProfessionalCertificate(
      institution: json['institution'],
      photoUrl: json['photoUrl'],
      title: json['title'],
      type: json['type'],
      verified: json['verified'],
      yearObtained: json['yearObtained'],
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'institution': institution,
      'photoUrl': photoUrl,
      'title': title,
      'type': type,
      'verified': verified,
      'yearObtained': yearObtained,
    };
  }
}

class ProfilePictureUrl {
  String large;
  String small;
  String thumb;

  ProfilePictureUrl({
    required this.large,
    required this.small,
    required this.thumb,
  });

  factory ProfilePictureUrl.fromJson(Map<String, dynamic> json) {
    return ProfilePictureUrl(
      large: json['large'],
      small: json['small'],
      thumb: json['thumb'],
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'large': large,
      'small': small,
      'thumb': thumb,
    };
  }
}

///// lib/models/term_index_model.dart /////
import 'package:cloud_firestore/cloud_firestore.dart';

class TermIndex {
  String id;
  String term;
  Map<String, List<String>> associatedTerms;
  List<TherapistIndex> negative;
  List<TherapistIndex> positive;

  TermIndex({
    required this.id,
    required this.term,
    required this.associatedTerms,
    required this.negative,
    required this.positive,
  });

  factory TermIndex.fromJson(Map<String, dynamic> json, String id) {
    Map<String, List<String>> associatedTerms = {
      'equivalents': List<String>.from(json['equivalents'] ?? []),
      'related': List<String>.from(json['related'] ?? []),
      'subcategories': List<String>.from(json['subcategories'] ?? []),
    };

    List<TherapistIndex> negative = (json['negative'] as List)
        .map((item) => TherapistIndex.fromJson(item))
        .toList();

    List<TherapistIndex> positive = (json['positive'] as List)
        .map((item) => TherapistIndex.fromJson(item))
        .toList();

    return TermIndex(
      id: id,
      term: json['term'] ?? '',
      associatedTerms: associatedTerms,
      negative: negative,
      positive: positive,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'term': term,
      'associatedTerms': {
        'equivalents': associatedTerms['equivalents'],
        'related': associatedTerms['related'],
        'subcategories': associatedTerms['subcategories'],
      },
      'negative': negative.map((item) => item.toJson()).toList(),
      'positive': positive.map((item) => item.toJson()).toList(),
    };
  }
}

class TherapistIndex {
  String therapistId;

  TherapistIndex({
    required this.therapistId,
  });

  factory TherapistIndex.fromJson(Map<String, dynamic> json) {
    return TherapistIndex(
      therapistId: json['therapistId'] ?? '',
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'therapistId': therapistId,
    };
  }
}

///// lib/screens/admin/debug_screen/debug_screen.dart /////
import 'package:cached_network_image/cached_network_image.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:findatherapistapp/app_settings/theme_settings.dart';
import 'package:findatherapistapp/providers/providers_all.dart';
import 'package:findatherapistapp/utils/admin/find_best_therapist_by_aspects.dart';
import 'package:findatherapistapp/utils/admin/log_all_therapists.dart';
import 'package:findatherapistapp/widgets/Skeletons/SkeletonTherapistCard/skeleton_therapist_card.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../../models/gemini_tags_response_model.dart';
import '../../../models/term_index_model.dart';
import '../../../models/therapist_model.dart';
import '../../../services/gemini_service.dart';
import '../../../utils/admin/log_all_terms.dart';
import '../../../widgets/AppScaffold/app_scaffold.dart';
import '../../../services/firestore_service.dart';
import '../../../widgets/TherapistListCard/therapist_list_card.dart';
import '../../common/therapist_public_profile_screen/therapist_public_profile_screen.dart';

class DebugScreen extends ConsumerStatefulWidget {
  const DebugScreen({super.key});

  @override
  ConsumerState<DebugScreen> createState() => _DebugScreenState();
}

class _DebugScreenState extends ConsumerState<DebugScreen> {
  late Future<List<TherapistModel>> _futureTherapists;

  @override
  void initState() {
    super.initState();
    _futureTherapists = _fetchTherapists();
  }

  Future<List<TherapistModel>> _fetchTherapists() async {
    try {
      FirebaseFirestore firestore = FirestoreService.instance;
      QuerySnapshot snapshot = await firestore.collection('therapists').get();
      return snapshot.docs.map((doc) {
        return TherapistModel.fromJson(
          doc.data() as Map<String, dynamic>,
          doc.id,
        );
      }).toList();
    } catch (e) {
      debugPrint('Failed to get therapists: $e');
      return [];
    }
  }

  Future<void> _refreshTherapists() async {
    debugPrint('Refreshing therapists list...');
    setState(() {
      _futureTherapists = _fetchTherapists();
    });
  }

  @override
  Widget build(BuildContext context) {
    return AppScaffold(
      scrollPhysics: NeverScrollableScrollPhysics(),
      ignoreGlobalPadding: true,
      appBarTitle: 'Debug Screen',
      isProtected: false,
      body: FutureBuilder<List<TherapistModel>>(
        future: _futureTherapists,
        builder: (context, snapshot) {
          if ((snapshot.connectionState == ConnectionState.waiting &&
                  (snapshot.data == null || snapshot.data!.isEmpty)) ||
              _futureTherapists == null) {
            return SingleChildScrollView(
              child: Column(
                children: List.generate(7, (index) {
                  return const SkeletonTherapistCard();
                }),
              ),
            );
          } else if (snapshot.hasError) {
            return const Center(child: Text('Failed to load therapists'));
          } else if (!snapshot.hasData || snapshot.data!.isEmpty) {
            return const Center(child: Text('No therapists found'));
          }
          //
          // return ElevatedButton(
          //   onPressed: () async {
          //     return logAllTherapists();
          //     // var userAspects = Aspects(
          //     //   positive: [
          //     //     'anxiety',
          //     //     'depression',
          //     //     'stress',
          //     //     'relationships',
          //     //     'self-esteem',
          //     //     'astrological-counseling',
          //     //   ],
          //     //   negative: [
          //     //     'addiction',
          //     //     'trauma',
          //     //     'grief',
          //     //     'anger',
          //     //     'eating disorders',
          //     //   ],
          //     // );
          //     // findBestTherapist(userAspects);
          //   },
          //   child: const Text('Log all therapists'),
          // );

          return RefreshIndicator(
            onRefresh: _refreshTherapists,
            child: ListView.builder(
              clipBehavior: Clip.antiAliasWithSaveLayer,
              physics: const AlwaysScrollableScrollPhysics(),
              shrinkWrap: true,
              itemCount: snapshot.data?.length,
              itemBuilder: (context, index) {
                final therapist = snapshot.data![index];

                return TherapistListCard(
                  therapist: therapist,
                  onTap: () {
                    Navigator.push(
                      context,
                      MaterialPageRoute(
                        builder: (context) =>
                            TherapistPublicProfileScreen(therapist: therapist),
                      ),
                    );
                  },
                );
              },
            ),
          );
        },
      ),
    );
  }
}

///// lib/screens/user_area/user_request_screen/user_request_screen.dart /////
import 'dart:developer';

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:findatherapistapp/widgets/LoadingCircle/loading_circle.dart';
import 'package:findatherapistapp/services/gemini_service.dart';
import 'package:findatherapistapp/services/speech_to_text_service.dart';
import '../../../app_settings/theme_settings.dart';
import '../../../models/gemini_tags_response_model.dart';
import '../../../providers/providers_all.dart';
import '../../../utils/debug/error_code_to_text.dart';
import '../../../utils/ui/is_dark_mode.dart';
import '../../../widgets/AppScaffold/app_scaffold.dart';
import '../../../generated/l10n.dart';

class UserRequestScreen extends ConsumerStatefulWidget {
  const UserRequestScreen({super.key});

  @override
  ConsumerState<UserRequestScreen> createState() => _UserRequestScreenState();
}

class _UserRequestScreenState extends ConsumerState<UserRequestScreen> {
  final TextEditingController _requestController = TextEditingController();
  String _requestLastText = '';
  final GeminiService _geminiService = GeminiService();
  final SpeechToTextService _speechService = SpeechToTextService();
  GeminiTagsResponse? _tagsResponse;
  bool isSendingRequest = false;
  bool _isListening = false;

  @override
  void initState() {
    super.initState();
    _initializeSpeech();
  }

  void _initializeSpeech() async {
    await _speechService.initialize();
  }

  @override
  void dispose() {
    _speechService.stopListening();
    _requestController.dispose();
    super.dispose();
  }

  void _startListening() async {
    var localeService = ref.watch(localeProvider);

    setState(() {
      _isListening = true;
      _requestLastText = _requestController.text;
    });

    _speechService.startListening(
      localeId: localeService.locale.languageCode,
      onResult: (text) {
        setState(() {
          _requestController.text = _requestLastText + text;
        });
      },
    );
  }

  void _stopListening() async {
    _speechService.stopListening();
    setState(() => _isListening = false);

    if (_requestController.text.isNotEmpty) {
      await _improveTranscription(_requestController.text);
    }
  }

  Future<void> _improveTranscription(String text) async {
    setState(() {
      isSendingRequest = true;
    });
    final improvedText = await _geminiService.improveTranscription(text);
    setState(() {
      _requestController.text = improvedText;
      isSendingRequest = false;
      _requestLastText = improvedText;
    });
  }

  @override
  Widget build(BuildContext context) {
    return AppScaffold(
      useTopAppBar: true,
      isProtected: true,
      showScreenTitleInAppBar: false,
      appBarTitle: 'Request a Therapist',
      body: SingleChildScrollView(
          child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: <Widget>[
          Text('${S.of(context).tellUsWhatYouAreLookingFor}:',
              style: Theme.of(context).textTheme.headlineSmall),
          const SizedBox(height: 20),
          Stack(
            children: [
              TextField(
                controller: _requestController,
                decoration: InputDecoration(
                  hintText: S.of(context).requestTextFieldHintText,
                  hintStyle: Theme.of(context).textTheme.bodyLarge?.copyWith(
                        color: Theme.of(context)
                            .colorScheme
                            .onSurface
                            .withOpacity(0.5),
                      ),
                  border: const OutlineInputBorder(),
                ),
                maxLines: 18,
                enabled: !isSendingRequest,
              ),
              Positioned(
                right: 13,
                bottom: 13,
                child: InkWell(
                    borderRadius: BorderRadius.circular(50),
                    onTap: _isListening ? _stopListening : _startListening,
                    child: Container(
                      padding: const EdgeInsets.all(10),
                      decoration: BoxDecoration(
                        color: _isListening ? Colors.red : Colors.transparent,
                        shape: BoxShape.circle,
                      ),
                      child: Icon(
                        _isListening ? Icons.mic : Icons.mic_none,
                        color: _isListening && !isDarkMode(context)
                            ? Colors.white
                            : null,
                        size: 30,
                      ),
                    )),
              ),
            ],
          ),
          const SizedBox(height: 15),
          Row(
            mainAxisAlignment: MainAxisAlignment.end,
            children: <Widget>[
              ElevatedButton(
                  style: ElevatedButton.styleFrom(
                    minimumSize: const Size(130, ThemeSettings.buttonsHeight),
                  ),
                  onPressed: isSendingRequest ? null : _sendRequest,
                  child: isSendingRequest
                      ? SizedBox(
                          height: 20,
                          width: 20,
                          child: LoadingCircle(
                            color: Theme.of(context).colorScheme.onPrimary,
                          ),
                        )
                      : Text(S.of(context).sendButton)),
            ],
          ),
          if (_tagsResponse != null) ...[
            if (_tagsResponse!.error != null) ...[
              const SizedBox(height: 15),
              Container(
                width: double.infinity,
                decoration: BoxDecoration(
                  color: ThemeSettings.errorColor.shade50,
                  border: Border.all(
                    color: ThemeSettings.errorColor,
                  ),
                ),
                child: Padding(
                  padding: const EdgeInsets.all(12.0),

                  /// add warning icon big and centered

                  child: Column(
                    children: [
                      const SizedBox(height: 10),
                      const Icon(Icons.warning, color: Colors.red, size: 40),
                      const SizedBox(height: 10),
                      Text(
                        S.of(context).ohNoSomethingWentWrong,
                        textAlign: TextAlign.center,
                        style:
                            Theme.of(context).textTheme.headlineSmall?.copyWith(
                                  color: ThemeSettings.errorColor,
                                ),
                      ),
                      const SizedBox(height: 10),
                      Text(
                        ErrorCodeToText.getGeminiErrorMessage(
                            _tagsResponse!.error!, context),
                        textAlign: TextAlign.center,
                        style: Theme.of(context).textTheme.bodyLarge?.copyWith(
                              color: ThemeSettings.errorColor,
                            ),
                      ),
                      const SizedBox(height: 10),
                    ],
                  ),
                ),
              )
            ],
            if (_tagsResponse!.error == null)
              Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  const SizedBox(height: 10),
                  const Divider(),
                  const SizedBox(height: 10),
                  Row(
                    children: [
                      Flexible(
                        child: Text(
                          S.of(context).positiveAspectsTitle,
                          style: Theme.of(context).textTheme.headlineMedium,
                        ),
                      ),
                    ],
                  ),
                  const SizedBox(height: 5),
                  Text(
                    '(${S.of(context).positiveAspectsDescription})',
                    style: Theme.of(context).textTheme.titleMedium,
                  ),
                  const SizedBox(height: 10.0),
                  Wrap(
                    spacing: 8.0,
                    runSpacing: 4.0,
                    children: _tagsResponse!.tags.positive.isNotEmpty
                        ? _tagsResponse!.tags.positive
                            .map((aspect) => Chip(
                                  side: const BorderSide(
                                      color: Colors.green, width: 1.0),
                                  label: Text(aspect,
                                      style: Theme.of(context)
                                          .textTheme
                                          .bodyLarge
                                          ?.copyWith(
                                            color: isDarkMode(context)
                                                ? Colors.green
                                                : Colors.white,
                                          )),
                                  backgroundColor: isDarkMode(context)
                                      ? Colors.transparent
                                      : Colors.green.shade400,
                                ))
                            .toList()
                        : [
                            Padding(
                              padding: const EdgeInsets.symmetric(
                                  horizontal: 8.0, vertical: 13.0),
                              child: Text(S.of(context).notFound,
                                  style: Theme.of(context).textTheme.bodyLarge),
                            ),
                          ],
                  ),
                  const SizedBox(height: 5),
                  const Divider(),
                  const SizedBox(height: 5),
                  Text(
                    S.of(context).negativeAspectsTitle,
                    style: Theme.of(context).textTheme.headlineMedium,
                  ),
                  const SizedBox(height: 5),
                  Text(
                    '(${S.of(context).negativeAspectsDescription})',
                    style: Theme.of(context).textTheme.titleMedium,
                  ),
                  const SizedBox(height: 10.0),
                  Wrap(
                    spacing: 8.0,
                    runSpacing: 4.0,
                    children: _tagsResponse!.tags.negative.isNotEmpty
                        ? _tagsResponse!.tags.negative
                            .map((aspect) => Chip(
                                  side: const BorderSide(
                                      color: Colors.red, width: 1.0),
                                  label: Text(aspect,
                                      style: Theme.of(context)
                                          .textTheme
                                          .bodyLarge
                                          ?.copyWith(
                                            color: isDarkMode(context)
                                                ? Colors.red
                                                : Colors.white,
                                          )),
                                  backgroundColor: isDarkMode(context)
                                      ? Colors.transparent
                                      : Colors.red.shade400,
                                ))
                            .toList()
                        : [
                            Padding(
                              padding: const EdgeInsets.symmetric(
                                  horizontal: 8.0, vertical: 13.0),
                              child: Text(S.of(context).notFound,
                                  style: Theme.of(context).textTheme.bodyLarge),
                            ),
                          ],
                  ),
                  const SizedBox(height: 5),
                  const Divider(),
                ],
              ),
          ],
          const SizedBox(height: 60),
        ],
      )),
    );
  }

  Future<GeminiTagsResponse?> _sendRequest() async {
    if (isSendingRequest) return null;

    setState(() {
      isSendingRequest = true;
    });
    final inputText = _requestController.text;
    final GeminiTagsResponse geminiResponse =
        await _geminiService.getTherapyTags(inputText);
    setState(() {
      isSendingRequest = false;
      _tagsResponse = geminiResponse;
    });

    log(geminiResponse.toJson().toString());

    return geminiResponse;
  }
}

///// lib/utils/admin/find_best_therapist_by_aspects.dart /////
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/cupertino.dart';
import 'package:findatherapistapp/services/firestore_service.dart';
import 'package:findatherapistapp/models/therapist_model.dart';

Future<void> findBestTherapist(Aspects userAspects) async {
  FirebaseFirestore firestore = FirestoreService.instance;

  try {
    QuerySnapshot therapistSnapshot =
        await firestore.collection('therapists').get();
    List<QueryDocumentSnapshot> therapistDocs = therapistSnapshot.docs;

    List<Map<String, dynamic>> matchScores = [];

    for (var therapistDoc in therapistDocs) {
      var therapistData = therapistDoc.data() as Map<String, dynamic>;
      TherapistModel therapist =
          TherapistModel.fromJson(therapistData, therapistDoc.id);

      int positiveMatches = 0;
      int negativeMatches = 0;

      for (var positive in userAspects.positive) {
        if (therapist.aspects.positive.contains(positive)) {
          positiveMatches++;
        }
        if (therapist.aspects.negative.contains(positive)) {
          negativeMatches++;
        }
      }

      for (var userNegativeAspect in userAspects.negative) {
        if (therapist.aspects.positive.contains(userNegativeAspect)) {
          negativeMatches++;
        }
        if (therapist.aspects.negative.contains(userNegativeAspect)) {
          negativeMatches++;
        }
      }

      int totalAspects =
          userAspects.positive.length + userAspects.negative.length;
      double matchScore = totalAspects > 0
          ? ((positiveMatches - negativeMatches) / totalAspects) * 100
          : 0.0;

      matchScores.add({
        'therapistId': therapist.id,
        'therapistName':
            '${therapist.therapistInfo.firstName} ${therapist.therapistInfo.lastName}',
        'matchScore': matchScore,
      });
    }

    matchScores.sort((a, b) => b['matchScore'].compareTo(a['matchScore']));

    for (var match in matchScores) {
      debugPrint(
          'Therapist: ${match['therapistName']}, Match Score: ${match['matchScore']}%');
    }
  } catch (e) {
    debugPrint('Failed to find best therapist: $e');
  }
}

///// lib/services/gemini_service.dart /////
import 'package:google_generative_ai/google_generative_ai.dart' as google_ai;
import 'dart:convert';
import '../app_settings/env_settings.dart';
import '../models/gemini_tags_response_model.dart';
import '../services/error_reporting_service.dart';

class GeminiService {
  final String apiKey = EnvSettings.googleGenerativeApiKey;

  Future<GeminiTagsResponse> getTherapyTags(String inputText) async {
    final model = google_ai.GenerativeModel(
      model: 'gemini-1.5-flash-latest',
      apiKey: apiKey,
    );

    final prompt = '''
Input Text: $inputText

Instructions for the AI: Your task is to analyze the provided text and extract key information essential for classifying and understanding the individual's therapeutic needs. Generate a structured object named tags that includes two arrays, positive and negative, to encapsulate:

Convert All Terms to English and Lowercase: Regardless of the input text's language, ensure all extracted terms are translated into English and presented in lowercase. This includes types of therapy, personal challenges, and any preferences or characteristics mentioned.
Use Hyphens for Multi-Word Terms: For concepts consisting of more than one word, connect these words with hyphens instead of spaces. Ensure these hyphen-connected terms are also in lowercase to maintain data uniformity and facilitate easier data processing.
Types of Therapy Mentioned: Identify any specific therapy types mentioned (e.g., cbt, jungian-analysis, emdr) and list them under the appropriate category based on the individual's explicit preference for or against them.
Personal Challenges: Extract personal challenges or issues mentioned (such as low-self-esteem, stress-triggered-depressive-episodes) and convert them into atomized, hyphen-connected terms in lowercase. Place them in the 'positive' array if the individual seeks help for these issues.
Therapy Preferences and Other Relevant Details: If the text includes specific preferences regarding therapy modality or other relevant details (like interest in astrology, seeking personal-growth), add these to the 'positive' array, using hyphens for two-word terms, and ensure all are in lowercase.
Expected Output: A structured object tags with two arrays, positive and negative, that accurately reflect the key information from the text, correctly formatted in English and entirely in lowercase. This structure aims to facilitate precise matching in a therapy search database.
    ''';

    try {
      final Iterable<google_ai.Content> content = [
        google_ai.Content.text(prompt),
      ];
      final google_ai.GenerateContentResponse response =
          await model.generateContent(content);

      if (response.candidates.isEmpty) {
        return GeminiTagsResponse(
            tags: Tags(positive: [], negative: []),
            error: GeminiErrorResponse(
                message: 'No candidates found in response',
                code: 'no-candidates'),
            candidates: []);
      }

      String? responseText;
      for (var candidate in response.candidates) {
        if (candidate.text != null && candidate.text!.isNotEmpty) {
          responseText = candidate.text;
          break;
        }
      }

      if (responseText == null) {
        return GeminiTagsResponse(
            tags: Tags(positive: [], negative: []),
            error: GeminiErrorResponse(
                message: 'No text found in response candidates',
                code: 'no-text-found-in-response'),
            candidates: response.candidates
                    .map((candidate) => Candidate(
                          text: candidate.text,
                          safetyRatings: candidate.safetyRatings
                              ?.map((rating) => SafetyRating(
                                    category: rating.category.toString(),
                                    probability: rating.probability.toString(),
                                  ))
                              .toList(),
                        ))
                    .toList() ??
                []);
      }

      // Extract only the JSON part of the response
      final jsonString = _extractJson(responseText);
      if (jsonString.isEmpty) {
        return GeminiTagsResponse(
            tags: Tags(positive: [], negative: []),
            error: GeminiErrorResponse(
                message: 'No JSON found in response text',
                code: 'no-json-found-in-response-text'),
            candidates: response.candidates
                    .map((candidate) => Candidate(
                          text: candidate.text,
                          safetyRatings: candidate.safetyRatings
                              ?.map((rating) => SafetyRating(
                                    category: rating.category.toString(),
                                    probability: rating.probability.toString(),
                                  ))
                              .toList(),
                        ))
                    .toList() ??
                []);
      }

      final jsonResponse = jsonDecode(jsonString);
      final geminiTagsResponse = GeminiTagsResponse.fromJson(jsonResponse);
      geminiTagsResponse.candidates
          ?.addAll(response.candidates.map((candidate) => Candidate(
                text: candidate.text,
                safetyRatings: candidate.safetyRatings
                    ?.map((rating) => SafetyRating(
                          category: rating.category.toString(),
                          probability: rating.probability.toString(),
                        ))
                    .toList(),
              )));
      return geminiTagsResponse;
    } on google_ai.GenerativeAIException catch (e, stackTrace) {
      await ErrorReportingService.reportError(e, stackTrace, null,
          screen: 'GeminiService',
          errorLocation: 'getTherapyTags',
          additionalInfo: [
            'User input text: $inputText',
          ]);

      if (e.message == 'Candidate was blocked due to safety') {
        return GeminiTagsResponse(
            tags: Tags(positive: [], negative: []),
            error: GeminiErrorResponse(
              message: e.message,
              code: 'candidate-blocked-due-to-safety',
            ),
            candidates: []);
      }

      return GeminiTagsResponse(
          tags: Tags(positive: [], negative: []),
          error: GeminiErrorResponse(
            message: e.message,
            code: 'generative-ai-error',
          ),
          candidates: []);
    } catch (e, stackTrace) {
      await ErrorReportingService.reportError(e, stackTrace, null,
          screen: 'GeminiService',
          errorLocation: 'getTherapyTags',
          additionalInfo: [
            'User input text: $inputText',
          ]);
      return GeminiTagsResponse(
          tags: Tags(positive: [], negative: []),
          error: GeminiErrorResponse(
            message: 'Unknown error occurred',
            code: 'unknown-error',
          ),
          candidates: []);
    }
  }

  String _extractJson(String responseText) {
    final regex = RegExp(r'\{.*\}', dotAll: true);
    final match = regex.firstMatch(responseText);
    if (match != null) {
      return match.group(0) ?? '';
    } else {
      return '';
    }
  }

  Future<String> improveTranscription(String text) async {
    final model = google_ai.GenerativeModel(
      model: 'gemini-1.5-flash-latest',
      apiKey: apiKey,
    );

    final prompt = '''
    Input Text: $text

    Instructions for the AI: This text has been transcribed from an audio input and may contain inaccuracies in punctuation and wording. Your task is to improve the text by correcting any errors and making it more coherent and cohesive. Ensure that the improved text is a faithful representation of what the user intended to say, and correct words if necessary to maintain coherence. And ALWAYS return the text in its original language. If the text is empty or contains no errors, return the original text as is. Never reply anything with your own words or opinions.

    Expected Output: The improved text, well-punctuated and corrected, in a readable format.
    ''';

    try {
      final Iterable<google_ai.Content> content = [
        google_ai.Content.text(prompt),
      ];
      final google_ai.GenerateContentResponse response =
          await model.generateContent(content);

      if (response.candidates.isEmpty) {
        return text;
      }

      String? responseText;
      for (var candidate in response.candidates) {
        if (candidate.text != null && candidate.text!.isNotEmpty) {
          responseText = candidate.text;
          break;
        }
      }

      return responseText ?? text;
    } catch (e) {
      return text;
    }
  }
}

///// lib/models/gemini_tags_response_model.dart /////
class GeminiTagsResponse {
  final Tags tags;
  final GeminiErrorResponse? error;
  final List<Candidate>? candidates;

  GeminiTagsResponse(
      {this.error, required this.tags, this.candidates = const []});

  factory GeminiTagsResponse.fromJson(Map<String, dynamic> json) {
    return GeminiTagsResponse(
      tags: Tags.fromJson(json['tags']),
      error: json['error'] != null
          ? GeminiErrorResponse(message: json['error'], code: null)
          : null,
      candidates: (json['candidates'] as List<dynamic>?)
              ?.map((candidate) => Candidate.fromJson(candidate))
              .toList() ??
          [],
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'tags': tags.toJson(),
      'error': error?.toJson(),
      'candidates': candidates?.map((candidate) => candidate.toJson()).toList(),
    };
  }
}

class Tags {
  final List<String> positive;
  final List<String> negative;

  Tags({required this.positive, required this.negative});

  factory Tags.fromJson(Map<String, dynamic> json) {
    return Tags(
      positive: List<String>.from(json['positive']),
      negative: List<String>.from(json['negative']),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'positive': positive,
      'negative': negative,
    };
  }
}

class Candidate {
  final String? text;
  final List<SafetyRating>? safetyRatings;

  Candidate({this.text, this.safetyRatings});

  factory Candidate.fromJson(Map<String, dynamic> json) {
    return Candidate(
      text: json['text'],
      safetyRatings: (json['safetyRatings'] as List<dynamic>?)
          ?.map((rating) => SafetyRating.fromJson(rating))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'text': text,
      'safetyRatings': safetyRatings?.map((rating) => rating.toJson()).toList(),
    };
  }
}

class GeminiErrorResponse {
  final String? message;
  final String? code;

  GeminiErrorResponse({this.message, this.code});

  factory GeminiErrorResponse.fromJson(Map<String, dynamic> json) {
    return GeminiErrorResponse(
      message: json['message'],
      code: json['code'],
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'message': message,
      'code': code,
    };
  }

  @override
  String toString() {
    return 'GeminiError{message: $message, code: $code}';
  }
}

class SafetyRating {
  final String category;
  final String probability;

  SafetyRating({required this.category, required this.probability});

  factory SafetyRating.fromJson(Map<String, dynamic> json) {
    return SafetyRating(
      category: json['category'],
      probability: json['probability'],
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'category': category,
      'probability': probability,
    };
  }
}

