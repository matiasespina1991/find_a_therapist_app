.
├── README.md
├── _combined.txt
├── analysis_options.yaml
├── concatenate_dart_files.sh
├── firebase-debug.log
├── firebase.json
├── lib
│   ├── _bin
│   │   ├── _demo_widgets_screen.dart
│   │   └── config.dart
│   ├── _mock_data
│   │   └── _mock_therapists.dart
│   ├── app_settings
│   │   ├── app_general_settings.dart
│   │   ├── app_info.dart
│   │   ├── auth_config.dart
│   │   ├── env_settings.dart
│   │   ├── language_settings.dart
│   │   └── theme_settings.dart
│   ├── assets
│   │   ├── app_icons
│   │   │   ├── logo1.png
│   │   │   ├── logo2.jpg
│   │   │   ├── logo3.png
│   │   │   ├── lupe1.png
│   │   │   └── lupe2.webp
│   │   ├── app_logo
│   │   │   └── logo.png
│   │   ├── extra_dash_flags
│   │   │   ├── ac.svg
│   │   │   ├── as.svg
│   │   │   ├── do.svg
│   │   │   ├── in.svg
│   │   │   └── is.svg
│   │   ├── icons
│   │   │   ├── gold-plan-badge.png
│   │   │   └── verified-badge.png
│   │   ├── images
│   │   ├── lottie_animations
│   │   │   ├── animation.json
│   │   │   ├── animation10.json
│   │   │   ├── animation11.json
│   │   │   ├── animation2.json
│   │   │   ├── animation3.json
│   │   │   ├── animation4.json
│   │   │   ├── animation5.json
│   │   │   ├── animation6.json
│   │   │   ├── animation7.json
│   │   │   ├── animation8.json
│   │   │   ├── animation9.json
│   │   │   └── searching_for_a_doctor.lottie
│   │   └── placeholders
│   │       └── default_profile_picture.jpg
│   ├── firebase_options.dart
│   ├── generated
│   │   ├── intl
│   │   │   ├── messages_all.dart
│   │   │   ├── messages_de.dart
│   │   │   ├── messages_en.dart
│   │   │   └── messages_es.dart
│   │   └── l10n.dart
│   ├── globals.dart
│   ├── l10n
│   │   ├── intl_de.arb
│   │   ├── intl_en.arb
│   │   └── intl_es.arb
│   ├── main.dart
│   ├── models
│   │   ├── current_user_data.dart
│   │   ├── gemini_tags_response_model.dart
│   │   ├── general_models.dart
│   │   ├── term_index_model.dart
│   │   ├── theme_models.dart
│   │   └── therapist_model.dart
│   ├── providers
│   │   ├── auth_provider.dart
│   │   ├── locale_provider.dart
│   │   ├── providers_all.dart
│   │   ├── theme_provider.dart
│   │   ├── therapist_provider.dart
│   │   ├── therapists_languages_provider.dart
│   │   └── translate_profiles_providers.dart
│   ├── routes
│   │   └── routes.dart
│   ├── screens
│   │   ├── _example_screen.dart
│   │   ├── admin
│   │   │   └── debug_screen
│   │   ├── common
│   │   │   ├── all_therapists_screen
│   │   │   ├── aspects_screen
│   │   │   ├── loading_screen
│   │   │   ├── login_screen
│   │   │   ├── not_found_screen
│   │   │   ├── settings_screen
│   │   │   ├── therapist_public_profile_screen
│   │   │   └── welcome_main_screen
│   │   ├── therapist_area
│   │   │   └── therapist_personal_profile_screen
│   │   └── user_area
│   │       ├── therapist_result_screen
│   │       ├── user_profile_screen
│   │       └── user_request_screen
│   ├── services
│   │   ├── connectivity_service.dart
│   │   ├── error_reporting_service.dart
│   │   ├── firestore_service.dart
│   │   ├── gemini_service.dart
│   │   ├── profile_service.dart
│   │   ├── profiles_translate_delegate.dart
│   │   └── speech_to_text_service.dart
│   ├── theme
│   │   └── main_theme
│   │       ├── buttons_theme.dart
│   │       ├── chip_theme.dart
│   │       ├── input_theme.dart
│   │       └── main_theme.dart
│   ├── utils
│   │   ├── admin
│   │   │   ├── _list_of_new_therapists.dart
│   │   │   ├── add_current_user_as_therapist.dart
│   │   │   ├── add_current_user_to_database.dart
│   │   │   ├── add_email_prop_to_all_therapists.dart
│   │   │   ├── add_terms_as_subcategory.dart
│   │   │   ├── add_therapist.dart
│   │   │   ├── add_therapists_in_batch.dart
│   │   │   ├── consolidate_terms.dart
│   │   │   ├── find_best_therapist_by_aspects.dart
│   │   │   ├── log_all_terms.dart
│   │   │   ├── log_all_therapists.dart
│   │   │   ├── to_capital_case.dart
│   │   │   ├── update_all_therapists_aspects.dart
│   │   │   ├── update_props_on_therapists_docs.dart
│   │   │   └── update_terms_index_from_all_therapist.dart
│   │   ├── debug
│   │   │   ├── error_code_to_text.dart
│   │   │   ├── log_configurations.dart
│   │   │   └── notify_that_app_is_runing_in_debug_mode.dart
│   │   ├── functions
│   │   │   ├── profile_utils.dart
│   │   │   └── show_city_state_selection_modal.dart
│   │   ├── locale
│   │   │   ├── all_locales_list.dart
│   │   │   ├── build_language_text_with_flag.dart
│   │   │   ├── get_localized_language_names.dart
│   │   │   └── show_language_selection_modal.dart
│   │   ├── ui
│   │   │   └── get_dash_flag_by_country_code.dart
│   │   └── validation
│   │       └── is_email_valid.dart
│   └── widgets
│       ├── AppScaffold
│       │   └── app_scaffold.dart
│       ├── AspectSection
│       │   └── aspect_section.dart
│       ├── GooglePlacesAutocompleteTextField
│       │   └── google_place_autocomplete_text_field.dart
│       ├── LoadingCircle
│       │   └── loading_circle.dart
│       ├── LocationSelectionModal
│       │   └── location_selection_modal.dart
│       ├── ModalTopChip
│       │   └── modal_top_chip.dart
│       ├── NotificationModal
│       │   └── notification_modal.dart
│       ├── NotificationSnackbar
│       │   └── notification_snackbar.dart
│       ├── Skeletons
│       │   └── SkeletonTherapistCard
│       ├── ThemeAppBar
│       │   └── template_app_bar.dart
│       ├── ThemeFloatingSpeedDialMenu
│       │   └── theme_floating_speed_dial_menu.dart
│       ├── ThemeInputTextField
│       │   └── theme_input_text_field.dart
│       └── TherapistListCard
│           └── therapist_list_card.dart
├── pubspec.lock
├── pubspec.yaml
├── rename_imports.sh
└── template_app.iml

62 directories, 120 files
///// pubspec.yaml /////
name: findatherapistapp
description: "An app to easily find the perfect therapist."

publish_to: 'none' # Remove this line if you wish to publish to pub.dev

version: 1.0.0+1

environment:
  sdk: '>=3.2.6 <4.0.0'

dependencies:
  flutter:
    sdk: flutter
  flutter_localizations:
    sdk: flutter

  # Cupertino Icons is a Flutter plugin for using Cupertino icons in a Flutter app. (Example of use: Icon(CupertinoIcons.share))
  cupertino_icons: ^1.0.8
  # Riverpod is a Flutter plugin for managing state in a Flutter app.
  flutter_riverpod: ^2.5.1
  # Flutter Secure Storage is a Flutter plugin for storing data securely on the device.
  flutter_secure_storage: ^9.2.2
  # Google Fonts is a Flutter plugin for using Google Fonts in a Flutter app.
  google_fonts: ^6.2.1
  # Fluttertoast is a Flutter plugin for showing toast messages in a Flutter app.
  fluttertoast: ^8.2.6
  # Google Sign In is a Flutter plugin for signing with Google. It is a wrapper around the native Google Sign In libraries.
  google_sign_in: ^6.2.1
  # Sign In Button is a Flutter plugin for creating sign-in buttons in a Flutter app.
  sign_in_button: ^3.2.0
  # Go Router is a Flutter plugin for routing in a Flutter app.
  go_router: ^14.2.0
  # Google Generative AI is a Flutter plugin for using Google Generative AI in a Flutter app.
  google_generative_ai: ^0.4.3
  # Speech to Text is a Flutter plugin for converting speech to text in a Flutter app.
  speech_to_text: ^6.6.0
  # Country Picker is a Flutter plugin for selecting countries in a Flutter app.
  country_picker: ^2.0.26
  # Intl is a Flutter plugin for internationalization in a Flutter app.
  intl: any
  # Flutter Localized Locales is a Flutter plugin for using localized locales in a Flutter app.
  flutter_localized_locales: ^2.0.5
  # Expandable is a Flutter plugin for creating expandable widgets in a Flutter app.
  expandable: ^5.0.1
  # Google Mklit Translation is a Flutter plugin for translating text in a Flutter app.
  google_mlkit_translation: ^0.11.0
  # Number Paginator is a Flutter plugin for creating number paginators in a Flutter app.
  number_paginator: ^0.4.1
  # Google Places Autocomplete Text Field is a Flutter plugin for using Google Places Autocomplete in a Flutter app.
  google_places_autocomplete_text_field: ^0.1.3
  # Animated Do is a Flutter plugin for creating animations in a Flutter app.
  animate_do: ^3.3.4



#  # -----------------  GENERAL PACKAGES  -----------------
#  # Url Launcher is a Flutter plugin for launching a URL in the mobile platform. Supports iOS and Android.
#  url_launcher: ^6.3.0
#  # Cached network image is a Flutter library to show images from the internet and keep them in the cache directory.
  cached_network_image: ^3.3.1
#  # Google Fonts is a Flutter plugin for using Google Fonts in a Flutter app.
#  google_fonts: ^6.2.1
#  # Flutter Email Validator is a Flutter plugin for validating email addresses in a Flutter app.
#  email_validator: ^2.1.17
#  # Permission Handler is a Flutter plugin for requesting permissions in a Flutter app.
#  permission_handler: ^11.3.1
#  # Image Picker is a plugin for selecting images from the Android and iOS image library, and taking new pictures with the camera:
#  image_picker: ^1.1.2
  # Skeletonizer is a Flutter plugin for creating skeleton loading animations in a Flutter app.
  skeletonizer: ^1.3.0

  # Device Info Plus is a Flutter plugin for getting information about the device the app is running on.
  device_info_plus: ^10.1.0
  # Package Info Plus is a Flutter plugin for getting information about the package the app is running on.
  package_info_plus: ^8.0.0
#  # HTTP is a Flutter plugin for performing HTTP requests. It is a wrapper around the Dart http package.
#  http: ^1.2.1
#  # Webview is a Flutter plugin for rendering web content in a Flutter widget.
#  webview_flutter: ^4.8.0
#  # Share Plus is a Flutter plugin for sharing content (Links to the app, text, emails, files, etc.) from a Flutter app to other apps.
#  share_plus: ^9.0.0
#  # Add 2 Calendar is a Flutter plugin for adding events to the calendar in a Flutter app.
#  add_2_calendar: ^3.0.1
#  # Geo Locator is a Flutter plugin for getting the location of the device in a Flutter app.
#  geolocator: ^12.0.0
#  # Map Launcher is a Flutter plugin for launching maps in a Flutter app.
#  map_launcher: ^2.0.1
#  # Google Maps Flutter is a Flutter plugin for embedding Google Maps in a Flutter app.
#  google_maps_flutter: ^2.7.0
  # Connectivity Plus is a Flutter plugin for getting information about the network connectivity in a Flutter app.
  connectivity_plus: ^6.0.3
#  # Expandable is a Flutter plugin for creating expandable widgets in a Flutter app.
#  expandable: ^5.0.1
#  # Photo View is a Flutter plugin for showing photos in a full-screen view with zooming and panning gestures.
#  photo_view: ^0.15.0
#  # Percent Indicator is a Flutter plugin for showing percentage indicators in a Flutter app.
#  percent_indicator: ^3.0.1

#  # -----------------  WIDGET DESIGN PACKAGES  -----------------
  # Flutter Speed Dial is a Flutter plugin for creating a speed dial menu widget in a Flutter app.
  flutter_speed_dial: ^7.0.0
#  # Badges is a Flutter plugin for creating fancy animated badges in a Flutter app.
  badges: ^3.1.2
#  # Flutter Native Splash is a Flutter plugin for creating a splash screen in a Flutter app.
#  flutter_native_splash: ^2.4.0
#  # Another Flushbar is a Flutter plugin for creating custom snackbars in a Flutter app.
#  another_flushbar: ^1.12.30
#  # Awesome Dialog is a Flutter plugin for creating awesome dialogs in a Flutter app.
#  awesome_dialog: ^3.2.1
#  # Flutter Staggered Grid View is a Flutter plugin for creating staggered grid views in a Flutter app.
#  flutter_staggered_grid_view: ^0.7.0
#  # Animated Toggle Switch is a Flutter plugin for creating animated toggle switches in a Flutter app.
#  animated_toggle_switch: ^1.0.0
#  #Flutter Typeahead is a Flutter input where you can show suggestions to users as they type.
#  flutter_typeahead: ^2.0.0
#  # Mesh Gradient is a Flutter plugin for creating mesh gradients in a Flutter app.
#  mesh_gradient: ^1.3.6

  # -----------------  ANIMATIONS  -----------------
  # Lottie is a Flutter plugin for using Lottie animations in a Flutter app.
  lottie: ^3.1.2

#  # -----------------  FONT PACKAGES  -----------------
#  # Auto Size Text is a Flutter plugin for creating auto-size text in a Flutter app.
#  auto_size_text: ^3.0.0

#  # -----------------  ICONS PACKAGES  -----------------
#  # Material Design Icons is a Flutter plugin for using Material Design icons in a Flutter app. (Example of use: Icon(MdiIcons.add))
#  material_design_icons_flutter: ^7.0.7296
#  # Font Awesome Icons is a Flutter plugin for using Font Awesome icons in a Flutter app. (Example of use: Icon(FontAwesomeIcons.addressBook))
#  font_awesome_flutter: ^10.7.0
#  # Icofont Icons is a Flutter plugin for using Icofont icons in a Flutter app. (Example of use: Icon(IcoFontIcons.addressBook))
#  icofont_flutter: ^1.4.0

#  # -----------------  MEDIA PACKAGES  -----------------
#  # Video Player is a Flutter plugin for playing videos in a Flutter app.
#  video_player: ^2.8.7
#  # Audio Player is a Flutter plugin for playing audio in a Flutter app.
#  audioplayers: ^6.0.0

#  # -----------------  UI THEMES  -----------------
#  # Macos UI is a Flutter plugin for creating MacOS themes in a Flutter app.
#  macos_ui: ^2.0.7
#  # Chicago Theme is a Flutter plugin for creating Chicago themes in a Flutter app.
#  chicago_theme: ^0.4.3-dev
#  # Win32 GUI is a Flutter plugin for creating Win32 GUI themes in a Flutter app.
#  win32_gui 1.1.5

# ----------------- FIREBASE PACKAGES -----------------
#  # Firebase Core is a Flutter plugin to use the Firebase platform services.
  firebase_core: ^3.1.1
#  # Flutter Auth is a Flutter plugin that enables Android and iOS authentication using passwords, phone numbers, and identity providers like Google, Facebook, and Twitter.
  firebase_auth: ^5.1.1
#  # Cloud Firestore is a flexible, scalable database for mobile, web, and server development from Firebase and Google Cloud Platform.
  cloud_firestore: ^5.1.0

  country_state_city: ^0.1.6
  dash_flags: ^0.1.1
  flutter_svg: ^2.0.10+1
  image_picker: ^1.1.2
  #  # Firebase Database is a Flutter plugin to use the Firebase Realtime Database API and allow storing and syncing data with a NoSQL cloud database.
#  firebase_database: ^11.0.1
#  # Firebase Storage is a Flutter plugin to use the Firebase Cloud Storage API and allow uploading, downloading, and deleting files in the cloud.
  firebase_storage: ^12.0.1
  advanced_chips_input: ^0.1.5
#  # Firebase Messaging is a Flutter plugin to use the Firebase Cloud Messaging (FCM) API and allow sending push notifications to Android and iOS users.
#  firebase_messaging: ^15.0.1
#  # Firebase In-App Messaging is a Flutter plugin to use the Firebase In-App Messaging API and allow sending in-app messages to Android and iOS users.
#  firebase_in_app_messaging: ^0.8.0+1
#  # Firebase Crashlytics is a Flutter plugin to use the Firebase Crashlytics API and allow sending crash reports to Firebase.
#  firebase_crashlytics: ^4.0.1
#  # Firebase Analytics is a Flutter plugin to use the Firebase Analytics API and allow sending events to Google Analytics.
#  firebase_analytics: ^11.0.1
#  # Firebase Performance Monitoring is a Flutter plugin to use the Firebase Performance Monitoring API and allow sending performance data to Firebase.
#  firebase_performance: ^0.10.0+1
#  # Firebase Remote Config is a Flutter plugin to use the Firebase Remote Config API and allow fetching remote configuration values from Firebase.
#  firebase_remote_config: ^5.0.1


dev_dependencies:
  flutter_test:
    sdk: flutter
  flutter_lints: ^4.0.0
  intl_utils: ^2.8.7
  flutter_launcher_icons: "^0.13.1"

flutter_launcher_icons:
  android: "launcher_icon"
  ios: true
  image_path: "lib/assets/app_icons/logo3.png"
  min_sdk_android: 23


flutter:

  uses-material-design: true

  # To add assets to your application, add an assets section, like this:
  # assets:
  #   - images/a_dot_burr.jpeg
  #   - images/a_dot_ham.jpeg

  # To add entire folders of assets to your application, add an assets section, like this:
  assets:
    - lib/assets/lottie_animations/
    - lib/assets/images/
    - lib/assets/icons/
    - lib/assets/app_icons/
    - lib/assets/app_logo/
    - lib/assets/placeholders/
    - lib/assets/extra_dash_flags/


  # fonts:
  #   - family: Schyler
  #     fonts:
  #       - asset: fonts/Schyler-Regular.ttf
  #       - asset: fonts/Schyler-Italic.ttf
  #         style: italic
  #   - family: Trajan Pro
  #     fonts:
  #       - asset: fonts/TrajanPro.ttf
  #       - asset: fonts/TrajanPro_Bold.ttf
  #         weight: 700
  #


///// lib/app_settings/app_general_settings.dart /////
import '../routes/routes.dart';

class AppGeneralSettings {
  static const bool useTopAppBar = false;
  static const bool useFloatingSpeedDialMenu = true;
  static const bool useAppDrawerMenu = false;
  static const String minimumiOSVersion =
      '13.0'; // Set this manually in Xcode & Podfile
  static const String minimumAndroidVersion =
      '23'; // Set this manually in android/app/build.gradle
}

class DebugConfig {
  static const bool debugMode = true;
  static const String debugDatabaseId = 'debug-database';
  static const bool showDebugPrints = false;
  static RouteConfig debugScreen = Routes.userRequestScreen;
  static const forceDebugScreen =
      false; // If true, the route set in debugScreen will be shown and screen protection will be ignored
  static const bool bypassLoginScreen =
      false; // If true, login screen will be skipped
  // static const bool alwaysAllowNavigation =
  //     true;
}

///// lib/app_settings/app_info.dart /////
class AppInfo {
  static const String appName = 'FindYourTherapist';
}

///// lib/app_settings/auth_config.dart /////
class AuthConfig {
  static const bool useProtectedRoutes = true;
  static const bool useFirebase = true;
  static const bool allowGoogleSignIn = true;
  //TODO: Add scope functionality:
  static const List<String> googleSignInScopes = ['email'];
  static const bool allowFacebookSignIn = false;
  static const bool allowAppleSignIn = false;
  static const bool allowAnonymousSignIn = false;
  static const bool allowEmailSignIn = false;
}

///// lib/main.dart /////
import 'package:country_picker/country_picker.dart';
import 'package:findatherapistapp/providers/therapist_provider.dart';
import 'package:findatherapistapp/routes/routes.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:flutter/material.dart';
import 'package:flutter_localizations/flutter_localizations.dart';
import 'package:flutter_localized_locales/flutter_localized_locales.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:skeletonizer/skeletonizer.dart';
import 'package:findatherapistapp/providers/providers_all.dart';
import 'app_settings/auth_config.dart';
import 'globals.dart';
import 'app_settings/app_info.dart';
import 'app_settings/language_settings.dart';
import 'app_settings/theme_settings.dart';
import 'theme/main_theme/main_theme.dart';
import 'utils/debug/log_configurations.dart';
import 'generated/l10n.dart';

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await initializeApp();
  logConfigurations();
  runApp(const ProviderScope(child: MyApp()));
}

Future<void> initializeApp() async {
  if (AuthConfig.useFirebase) {
    try {
      await Firebase.initializeApp();
    } catch (e) {
      debugPrint('Error: Firebase initialization failed. $e');

      ///TODO: Show an error screen here or retry the initialization.
    }
  }
}

class MyApp extends ConsumerWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final themeNotifier = ref.watch(themeProvider);
    final localeNotifier = ref.watch(localeProvider);
    final isDarkMode = themeNotifier.themeMode == ThemeMode.dark;

    ref.listen(authProvider, (previous, next) {
      if (next.user != null) {
        Future(() {
          ref.read(therapistProvider.notifier).fetchTherapist(next.user!.uid);
        });
      }
    });

    return SkeletonizerConfig(
      data: SkeletonizerConfigData(
          effect: ShimmerEffect(
            baseColor: isDarkMode
                ? ThemeSettings.seedColor.withOpacity(0.1)
                : Colors.grey[300]!, // Color base del shimmer
            highlightColor: isDarkMode
                ? Colors.grey.withOpacity(0.25)
                : Colors.grey[100]!, // Color de resaltado del shimmer
            duration: const Duration(milliseconds: 2500),
            begin: Alignment.topLeft,
            end: Alignment.bottomRight,
          ),
          enableSwitchAnimation: true,
          containersColor: ThemeSettings.forceSeedColor
              ? ThemeSettings.seedColor
              : Colors.grey),
      child: MaterialApp.router(
        scaffoldMessengerKey: snackbarKey,
        title: AppInfo.appName,
        theme: MainTheme.lightTheme,
        darkTheme: MainTheme.darkTheme,
        themeMode: themeNotifier.themeMode,
        locale: localeNotifier.locale,
        supportedLocales: LanguageSettings.supportedLocales
            .map((e) => Locale.fromSubtags(languageCode: e))
            .toList(),
        localizationsDelegates: const [
          LocaleNamesLocalizationsDelegate(),
          CountryLocalizations.delegate,
          S.delegate,
          GlobalMaterialLocalizations.delegate,
          GlobalWidgetsLocalizations.delegate,
          GlobalCupertinoLocalizations.delegate,
        ],
        localeResolutionCallback: (locale, supportedLocales) {
          if (LanguageSettings.forceDefaultLanguage) {
            return const Locale(LanguageSettings.appDefaultLanguage);
          }
          if (locale != null) {
            for (var supportedLocale in supportedLocales) {
              if (supportedLocale.languageCode == locale.languageCode) {
                return supportedLocale;
              }
            }
          }
          return supportedLocales.first;
        },
        routerDelegate: Routes.router.routerDelegate,
        routeInformationParser: Routes.router.routeInformationParser,
        routeInformationProvider: Routes.router.routeInformationProvider,
      ),
    );
  }
}

///// lib/providers/providers_all.dart /////
import 'package:findatherapistapp/providers/therapists_languages_provider.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:findatherapistapp/providers/auth_provider.dart';
import 'package:findatherapistapp/providers/locale_provider.dart';
import 'package:findatherapistapp/providers/theme_provider.dart';

import '../services/connectivity_service.dart';

final authProvider = ChangeNotifierProvider((ref) => AuthorizationProvider());
final themeProvider = ChangeNotifierProvider((ref) => ThemeProvider());
final localeProvider = ChangeNotifierProvider((ref) => LocaleProvider());
final connectivityProvider =
    ChangeNotifierProvider((ref) => ConnectivityService());
final therapistsLanguagesProvider =
    ChangeNotifierProvider((ref) => TherapistsLanguagesProvider());

///// lib/providers/auth_provider.dart /////
import 'package:findatherapistapp/services/firestore_service.dart';
import 'package:flutter/material.dart';
import 'package:flutter_secure_storage/flutter_secure_storage.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:google_sign_in/google_sign_in.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:findatherapistapp/app_settings/app_general_settings.dart';
import 'package:findatherapistapp/app_settings/auth_config.dart';

class AuthorizationProvider extends ChangeNotifier {
  final FlutterSecureStorage storage = const FlutterSecureStorage();
  final FirebaseAuth? _firebaseAuth =
      AuthConfig.useFirebase ? FirebaseAuth.instance : null;
  final GoogleSignIn _googleSignIn =
      GoogleSignIn(scopes: AuthConfig.googleSignInScopes);
  String? _authToken;
  User? _user;
  bool _isLoading = true;
  bool _isUser = false;
  bool _isTherapist = false;

  AuthorizationProvider() {
    _initializeUser();
  }

  String? get authToken => _authToken;
  User? get user => _user;
  bool get isLoading => _isLoading;
  bool get isUser => _isUser;
  bool get isTherapist => _isTherapist;

  Future<void> _initializeUser() async {
    if (AuthConfig.useFirebase) {
      _user = _firebaseAuth?.currentUser;
      if (_user != null) {
        _authToken = _user!.uid;
        await _checkUserRole(_user!.uid);
      }
    } else {
      _authToken = await storage.read(key: 'auth_token');
    }

    if (DebugConfig.debugMode || DebugConfig.forceDebugScreen) {
      if (_authToken == null && _user == null) {
        debugPrint('[User is not authenticated.]');
      } else {
        debugPrint('[User is authenticated.]');
      }
    }

    if ((DebugConfig.bypassLoginScreen || DebugConfig.forceDebugScreen) &&
        (_authToken == null && _user == null)) {
      debugPrint('Signing user automatically...');
      GoogleSignInAccount? currentUser = await _googleSignIn.signIn();
      if (currentUser != null) {
        _user = await _handleSignIn(currentUser);
        if (_user != null) {
          _authToken = _user?.uid;
          await setAuthToken(_authToken!);
          await _checkUserRole(_user!.uid);
        }
      }
    }

    _isLoading = false;
    notifyListeners();

    _googleSignIn.onCurrentUserChanged
        .listen((GoogleSignInAccount? account) async {
      if (account != null) {
        _user = await _handleSignIn(account);
        if (_user != null) {
          _authToken = _user?.uid;
          await setAuthToken(_authToken!);
          await _checkUserRole(_user!.uid);
        }
      } else {
        _user = null;
        _authToken = null;
      }
      notifyListeners();
    });

    GoogleSignInAccount? currentUser = await _googleSignIn.signInSilently();
    if (currentUser != null) {
      _user = await _handleSignIn(currentUser);
      if (_user != null) {
        _authToken = _user?.uid;
        await setAuthToken(_authToken!);
        await _checkUserRole(_user!.uid);
        notifyListeners();
      }
    }
  }

  Future<User?> _handleSignIn(GoogleSignInAccount account) async {
    try {
      final GoogleSignInAuthentication googleAuth =
          await account.authentication;
      final AuthCredential credential = GoogleAuthProvider.credential(
        idToken: googleAuth.idToken,
        accessToken: googleAuth.accessToken,
      );

      if (AuthConfig.useFirebase) {
        final UserCredential authResult =
            await _firebaseAuth!.signInWithCredential(credential);
        return authResult.user;
      }
      return null;
    } catch (e) {
      debugPrint('Error during Google sign-in: $e');
      return null;
    }
  }

  Future<void> setAuthToken(String token) async {
    try {
      await storage.write(key: 'auth_token', value: token);
      _authToken = token;
      notifyListeners();
    } catch (error) {
      debugPrint('Error during setting auth token: $error');
    }
    _authToken = token;
    notifyListeners();
  }

  Future<void> clearAuthToken() async {
    await storage.delete(key: 'auth_token');
    _authToken = null;
    _user = null;
    debugPrint('Auth token cleared. User will be logged out.');
    notifyListeners();
  }

  Future<void> signOut(BuildContext context) async {
    if (DebugConfig.bypassLoginScreen) {
      debugPrint(
          'Error: Bypass Login Screen is on. Disable it from AppGeneralSettings.bypassLoginScreen in order to proceed with sign out.');
      return;
    }
    await clearAuthToken();
    if (AuthConfig.useFirebase) {
      await _firebaseAuth?.signOut();
    }

    if (AuthConfig.allowGoogleSignIn) {
      await _googleSignIn.signOut();
    }
  }

  bool get isAuthenticated =>
      !isLoading &&
      (DebugConfig.bypassLoginScreen ||
          (_authToken != null && _authToken!.isNotEmpty));

  Future<bool> signInWithEmail(String email, String password) async {
    bool success = false;
    try {
      debugPrint('Signing in with email/password...');

      if (AuthConfig.useFirebase) {
        final UserCredential authResult = await _firebaseAuth!
            .signInWithEmailAndPassword(email: email, password: password);
        _authToken = authResult.user!.uid;
        _user = authResult.user;
        await setAuthToken(_authToken!);
        await _checkUserRole(_user!.uid);
      } else {
        _authToken = email;
        await setAuthToken(_authToken!);
      }

      notifyListeners();
      success = true;
      debugPrint('User logged in successfully.✅');
      return success;
    } catch (error) {
      debugPrint('Error during email/password Sign In: ${error.toString()}');
      success = false;
      return success;
    }
  }

  Future<bool> signInWithGoogle() async {
    bool success = false;
    if (AuthConfig.allowGoogleSignIn) {
      try {
        debugPrint('Signing in with Google...');

        final GoogleSignInAccount? googleUser = await _googleSignIn.signIn();
        if (googleUser != null) {
          debugPrint('Google Sign In successful.');
          final GoogleSignInAuthentication googleAuth =
              await googleUser.authentication;
          final credential = GoogleAuthProvider.credential(
            accessToken: googleAuth.accessToken,
            idToken: googleAuth.idToken,
          );

          if (AuthConfig.useFirebase) {
            final UserCredential? authResult =
                await _firebaseAuth?.signInWithCredential(credential);
            _authToken = authResult?.user!.uid;
            _user = authResult?.user;
            await setAuthToken(_authToken!);
            await _checkUserRole(_user!.uid);
          } else {
            _authToken = googleAuth.accessToken;
            await setAuthToken(_authToken!);
          }

          notifyListeners();
          success = true;
          debugPrint('User logged in successfully.');
          return success;
        }
      } catch (error) {
        debugPrint(
            'Error trying to signing in user using Google: ${error.toString()}');
        success = false;
        return success;
      }
    }
    return success;
  }

  Future<void> _checkUserRole(String userId) async {
    _isUser = await checkIfUserExists(userId);
    _isTherapist = await checkIfTherapistExists(userId);

    debugPrint(
        'Current user is a registered User: $_isUser, Current user is a registered Therapist: $_isTherapist');

    notifyListeners();
  }

  Future<bool> checkIfUserExists(String userId) async {
    DocumentSnapshot userDoc =
        await FirestoreService.instance.collection('users').doc(userId).get();
    return userDoc.exists;
  }

  Future<bool> checkIfTherapistExists(String userId) async {
    DocumentSnapshot therapistDoc = await FirestoreService.instance
        .collection('therapists')
        .doc(userId)
        .get();
    return therapistDoc.exists;
  }
}

///// lib/widgets/AppScaffold/app_scaffold.dart /////
import 'dart:async';
import 'dart:ui';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:lottie/lottie.dart';
import 'package:findatherapistapp/app_settings/app_general_settings.dart';
import 'package:findatherapistapp/app_settings/auth_config.dart';
import 'package:findatherapistapp/providers/providers_all.dart';
import 'package:findatherapistapp/widgets/NotificationModal/notification_modal.dart';
import 'package:findatherapistapp/widgets/NotificationSnackbar/notification_snackbar.dart';
import 'package:skeletonizer/skeletonizer.dart';
import '../../app_settings/theme_settings.dart';
import '../../generated/l10n.dart';
import '../../models/general_models.dart';
import '../../routes/routes.dart';
import '../../screens/common/loading_screen/loading_screen.dart';
import '../ThemeAppBar/template_app_bar.dart';
import '../ThemeFloatingSpeedDialMenu/theme_floating_speed_dial_menu.dart';

class AppScaffold extends ConsumerStatefulWidget {
  final Widget body;
  final bool hideFloatingSpeedDialMenu;
  final String appBarTitle;
  final bool isProtected;
  final bool? useSafeArea;
  final ScrollPhysics? scrollPhysics;
  final LottieAnimationBackground? backgroundAnimation;
  final LottieAnimationBackground? backgroundAnimationDarkMode;
  final bool useTopAppBar;
  final bool showScreenTitleInAppBar;
  final EdgeInsetsGeometry? scaffoldPadding;
  final bool ignoreGlobalPadding;
  final List<Widget>? actions;
  final bool? centerTitle;
  final bool setFloatingSpeedDialToLoadingMode;
  final Function()? backButton;
  const AppScaffold(
      {super.key,
      required this.body,
      required this.appBarTitle,
      required this.isProtected,
      this.useSafeArea,
      this.hideFloatingSpeedDialMenu = false,
      this.scrollPhysics,
      this.backgroundAnimation,
      this.backgroundAnimationDarkMode,
      this.useTopAppBar = false,
      this.showScreenTitleInAppBar = true,
      this.scaffoldPadding,
      this.ignoreGlobalPadding = false,
      this.actions,
      this.centerTitle,
      this.setFloatingSpeedDialToLoadingMode = false,
      this.backButton});

  @override
  AppScaffoldState createState() => AppScaffoldState();
}

class AppScaffoldState extends ConsumerState<AppScaffold> {
  bool _connectivityChecked = false;
  bool _userWentOffline = false;
  Timer? _connectivityTimer;

  @override
  void initState() {
    super.initState();

    final String debugRouteName = DebugConfig.debugScreen.name;

    if (DebugConfig.forceDebugScreen && debugRouteName.isNotEmpty) {
      bool navigationAllowed = true;
      // if (DebugConfig.alwaysAllowNavigation) {
      //   navigationAllowed = true;
      // }
      debugPrint(
          '[DebugConfig.forceDebugScreen is set to true. Target screen is: $debugRouteName. Navigation ${navigationAllowed ? 'allowed' : 'is blocked'}.');
    }
  }

  @override
  void dispose() {
    _connectivityTimer?.cancel();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final auth = ref.watch(authProvider);
    final connectivity = ref.watch(connectivityProvider);

    if (auth.isLoading && !auth.isAuthenticated) {
      return const LoadingScreen();
    }

    _handleProtectedRoutes(auth);
    _checkConnectivity(connectivity);

    return SafeArea(
      bottom: widget.useSafeArea ?? ThemeSettings.useSafeArea,
      top: widget.useSafeArea ?? ThemeSettings.useSafeArea,
      child: Scaffold(
        appBar: (AppGeneralSettings.useTopAppBar || widget.useTopAppBar)
            ? ThemeAppBar(
                backButton: widget.backButton,
                appBarHeight: ThemeSettings.appBarHeight,
                centerTitle: widget.centerTitle,
                actions: widget.actions,
                title: widget.showScreenTitleInAppBar ? widget.appBarTitle : '',
              )
            : null,
        body: Stack(
          fit: StackFit.expand,
          children: [
            _buildBackgroundAnimation(),
            _buildMainContent(auth.isAuthenticated),
            _buildFloatingMenuBackdrop(),
          ],
        ),
        floatingActionButtonLocation: FloatingActionButtonLocation.endFloat,
        floatingActionButton: ThemeFloatingSpeedDialMenu(
          loadingMode: widget.setFloatingSpeedDialToLoadingMode,
          hideFloatingSpeedDialMenu: widget.hideFloatingSpeedDialMenu,
          isDialOpenNotifier: ValueNotifier(false),
        ),
      ),
    );
  }

  LoadingScreen? _handleProtectedRoutes(auth) {
    if (DebugConfig.forceDebugScreen) {
      return null;
    }

    if (!DebugConfig.bypassLoginScreen &&
        AuthConfig.useProtectedRoutes &&
        widget.isProtected &&
        !auth.isAuthenticated) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        context.go(Routes.loginScreen.path);
      });
    }

    if (!auth.isAuthenticated && widget.isProtected) {
      return const LoadingScreen();
    }
    return null;
  }

  void _checkConnectivity(connectivity) {
    if (!connectivity.isConnected && !_connectivityChecked) {
      _connectivityChecked = true;
      _connectivityTimer?.cancel();
      _connectivityTimer = Timer(
          const Duration(
              seconds: ThemeSettings.secondsUntilNoInternetNotification), () {
        if (!connectivity.isConnected) {
          WidgetsBinding.instance.addPostFrameCallback((_) {
            if (ModalRoute.of(context)?.isCurrent == true) {
              _showNoInternetNotification(context);
              _userWentOffline = true;
            }
          });
        }
      });
    } else if (connectivity.isConnected && _userWentOffline) {
      _connectivityTimer?.cancel();
      _connectivityChecked = false;
      _userWentOffline = false;

      WidgetsBinding.instance.addPostFrameCallback((_) {
        if (ModalRoute.of(context)?.isCurrent == true) {
          _showBackToInternetConnectionNotification(context);
        }
      });
    }
  }

  ScrollPhysics getScrollPhysics() {
    switch (ThemeSettings.defaultScrollPhysics) {
      case 'never':
        return const NeverScrollableScrollPhysics();
      case 'always':
        return const AlwaysScrollableScrollPhysics();
      case 'clamp':
        return const ClampingScrollPhysics();
      default:
        return const AlwaysScrollableScrollPhysics();
    }
  }

  LottieAnimationBackground? getLottieAnimation() {
    final bool isDarkMode =
        ref.watch(themeProvider).themeMode == ThemeMode.dark;
    if (isDarkMode && widget.backgroundAnimationDarkMode != null) {
      return widget.backgroundAnimationDarkMode;
    }
    return widget.backgroundAnimation;
  }

  Widget _buildBackgroundAnimation() {
    final animationConfig = getLottieAnimation();
    if (animationConfig != null && animationConfig.active) {
      final screenWidth = MediaQuery.of(context).size.width;
      final screenHeight = MediaQuery.of(context).size.height;
      return Stack(
        children: [
          Positioned(
            left: (screenWidth / 2) +
                animationConfig.x -
                (screenWidth * (animationConfig.width / 100) / 2),
            top: (screenHeight / 2) +
                animationConfig.y -
                (screenWidth * (animationConfig.width / 100) / 2),
            width: screenWidth * (animationConfig.width / 100),
            child: Opacity(
              opacity: animationConfig.opacity,
              child: Lottie.asset(
                animationConfig.animationPath,
              ),
            ),
          ),
          if (animationConfig.blur > 0)
            Positioned.fill(
              child: BackdropFilter(
                filter: ImageFilter.blur(
                    sigmaX: animationConfig.blur, sigmaY: animationConfig.blur),
                child: Container(
                  color: Colors.transparent,
                ),
              ),
            ),
        ],
      );
    }
    return const SizedBox.shrink();
  }

  Widget _buildMainContent(bool isAuthenticated) {
    if (widget.scrollPhysics is NeverScrollableScrollPhysics) {
      return Skeletonizer(
        enabled: !isAuthenticated &&
            widget.isProtected &&
            !DebugConfig.forceDebugScreen &&
            !DebugConfig.bypassLoginScreen,
        child: Padding(
          padding: widget.ignoreGlobalPadding
              ? EdgeInsets.zero
              : (widget.scaffoldPadding ?? ThemeSettings.scaffoldPadding),
          child: widget.body,
        ),
      );
    }

    return SingleChildScrollView(
      physics: widget.scrollPhysics ?? getScrollPhysics(),
      child: Column(
        children: [
          Skeletonizer(
            enabled: !isAuthenticated &&
                widget.isProtected &&
                !DebugConfig.forceDebugScreen &&
                !DebugConfig.bypassLoginScreen,
            child: Padding(
              padding: widget.ignoreGlobalPadding
                  ? EdgeInsets.zero
                  : (widget.scaffoldPadding ?? ThemeSettings.scaffoldPadding),
              child: widget.body,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildFloatingMenuBackdrop() {
    if (!widget.hideFloatingSpeedDialMenu &&
        AppGeneralSettings.useFloatingSpeedDialMenu) {
      return Positioned.fill(
        child: ValueListenableBuilder(
          valueListenable: ValueNotifier(false),
          builder: (context, value, child) {
            return value
                ? BackdropFilter(
                    filter: ImageFilter.blur(sigmaX: 1, sigmaY: 1),
                    child: Container(
                      color: Colors.black.withOpacity(0.1),
                    ),
                  )
                : const SizedBox.shrink();
          },
        ),
      );
    }
    return const SizedBox.shrink();
  }

  void _showNoInternetNotification(BuildContext context) {
    if (ThemeSettings.noInternetNotificationType == 'snackbar') {
      NotificationSnackbar.showSnackBar(
          message: S.of(context).noInternetConnection,
          icon: Icons.wifi_off,
          variant: 'info',
          duration: 'infinite');
    } else if (ThemeSettings.noInternetNotificationType == 'modal') {
      NotificationModal.noInternetConnection(
        context: context,
        onTapConfirm: () {
          setState(() {
            _connectivityChecked = true;
          });
        },
      );
    } else if (ThemeSettings.noInternetNotificationType == 'dialog') {
      showDialog(
        context: context,
        builder: (context) => AlertDialog(
          title: Text(S.of(context).noInternetConnection),
          content: Text(S.of(context).youAreCurrentlyOfflineMessage),
          actions: <Widget>[
            TextButton(
              child: Text(S.of(context).ok),
              onPressed: () {
                context.pop();
              },
            ),
          ],
        ),
      );
    }
  }

  void _showBackToInternetConnectionNotification(BuildContext context) {
    if (ThemeSettings.noInternetNotificationType == 'snackbar') {
      NotificationSnackbar.showSnackBar(
          message: S.of(context).backToInternetConnection,
          icon: Icons.wifi,
          variant: 'success',
          duration: 'long');
    } else if (ThemeSettings.noInternetNotificationType == 'modal') {
      NotificationModal.backToInternetConnection(
        context: context,
        onTapConfirm: () {
          setState(() {
            _connectivityChecked = false; // Allow for future offline checks
          });
        },
      );
    } else if (ThemeSettings.noInternetNotificationType == 'dialog') {
      NotificationSnackbar.showSnackBar(
          message: S.of(context).backToInternetConnection,
          icon: Icons.wifi,
          variant: 'success',
          duration: 'long');
    }
  }
}

///// lib/models/therapist_model.dart /////
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/foundation.dart';

class TherapistModel {
  String id;
  Timestamp createdAt;
  Timestamp updatedAt;
  Aspects aspects;
  Subscription subscription;
  Score score;
  TherapistInfo therapistInfo;
  bool isOnline;
  Timestamp lastOnline;

  TherapistModel({
    required this.id,
    required this.createdAt,
    required this.updatedAt,
    required this.aspects,
    required this.subscription,
    required this.score,
    required this.therapistInfo,
    required this.isOnline,
    required this.lastOnline,
  });

  factory TherapistModel.fromJson(Map<String, dynamic> json, String id) {
    try {
      return TherapistModel(
        id: id,
        createdAt: json['createdAt'] as Timestamp,
        updatedAt: json['updatedAt'] as Timestamp,
        aspects: Aspects.fromJson(json['aspects'] as Map<String, dynamic>),
        subscription:
            Subscription.fromJson(json['subscription'] as Map<String, dynamic>),
        score: Score.fromJson(json['score'] as Map<String, dynamic>),
        therapistInfo: TherapistInfo.fromJson(
            json['therapistInfo'] as Map<String, dynamic>),
        isOnline: json['isOnline'] as bool,
        lastOnline: json['lastOnline'] as Timestamp,
      );
    } catch (e, stack) {
      debugPrint('Error in TherapistModel.fromJson for ID $id: $e');
      debugPrint('Stack trace: $stack');
      throw e;
    }
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'createdAt': createdAt,
      'updatedAt': updatedAt,
      'aspects': aspects.toJson(),
      'subscription': subscription.toJson(),
      'score': score.toJson(),
      'therapistInfo': therapistInfo.toJson(),
      'isOnline': isOnline,
      'lastOnline': lastOnline,
    };
  }

  TherapistModel copyWith({
    Aspects? aspects,
    Subscription? subscription,
    Score? score,
    TherapistInfo? therapistInfo,
    bool? isOnline,
    Timestamp? lastOnline,
  }) {
    return TherapistModel(
      id: id,
      createdAt: createdAt,
      updatedAt: updatedAt,
      aspects: aspects ?? this.aspects,
      subscription: subscription ?? this.subscription,
      score: score ?? this.score,
      therapistInfo: therapistInfo ?? this.therapistInfo,
      isOnline: isOnline ?? this.isOnline,
      lastOnline: lastOnline ?? this.lastOnline,
    );
  }
}

class Term {
  String term;
  bool public;

  Term({
    required this.term,
    required this.public,
  });

  factory Term.fromJson(Map<String, dynamic> json) {
    try {
      return Term(
        term: json['term'] as String,
        public: json['public'] as bool,
      );
    } catch (e, stack) {
      debugPrint('Error in Term.fromJson: $e');
      debugPrint('Stack trace: $stack');
      throw e;
    }
  }

  Map<String, dynamic> toJson() {
    return {
      'term': term,
      'public': public,
    };
  }
}

class Aspects {
  List<Term> positive;
  List<Term> negative;

  Aspects({
    required this.positive,
    required this.negative,
  });

  factory Aspects.fromJson(Map<String, dynamic> json) {
    try {
      return Aspects(
        positive: (json['positive'] as List)
            .map((item) => Term.fromJson(item as Map<String, dynamic>))
            .toList(),
        negative: (json['negative'] as List)
            .map((item) => Term.fromJson(item as Map<String, dynamic>))
            .toList(),
      );
    } catch (e, stack) {
      debugPrint('Error in Aspects.fromJson: $e');
      debugPrint('Stack trace: $stack');
      throw e;
    }
  }

  Map<String, dynamic> toJson() {
    return {
      'positive': positive.map((term) => term.toJson()).toList(),
      'negative': negative.map((term) => term.toJson()).toList(),
    };
  }
}

class Subscription {
  Timestamp endsAt;
  String plan;
  Timestamp startedAt;
  bool autoRenewal;

  Subscription({
    required this.endsAt,
    required this.plan,
    required this.startedAt,
    required this.autoRenewal,
  });

  factory Subscription.fromJson(Map<String, dynamic> json) {
    try {
      return Subscription(
        endsAt: json['endsAt'] as Timestamp,
        plan: json['plan'] as String,
        startedAt: json['startedAt'] as Timestamp,
        autoRenewal: json['autoRenewal'] as bool,
      );
    } catch (e, stack) {
      debugPrint('Error in Subscription.fromJson: $e');
      debugPrint('Stack trace: $stack');
      throw e;
    }
  }

  Map<String, dynamic> toJson() {
    return {
      'endsAt': endsAt,
      'plan': plan,
      'startedAt': startedAt,
      'autoRenewal': autoRenewal,
    };
  }
}

class Score {
  double rating;
  int amountRatings;

  Score({
    required this.rating,
    required this.amountRatings,
  });

  factory Score.fromJson(Map<String, dynamic> json) {
    try {
      return Score(
        rating: (json['rating'] as num).toDouble(),
        amountRatings: json['amountRatings'] as int,
      );
    } catch (e, stack) {
      debugPrint('Error in Score.fromJson: $e');
      debugPrint('Stack trace: $stack');
      throw e;
    }
  }

  Map<String, dynamic> toJson() {
    return {
      'rating': rating,
      'amountRatings': amountRatings,
    };
  }
}

class TherapistInfo {
  Timestamp birthday;
  String firstName;
  String email;
  String intro;
  String lastName;
  Location location;
  MeetingType meetingType;
  Phone phone;
  String privateNotes;
  ProfilePictureUrl profilePictureUrl;
  String publicPresentation;
  List<String> specializations;
  List<String> spokenLanguages;
  List<ProfessionalCertificate> professionalCertificates;
  String title;
  bool userInfoIsVerified;

  TherapistInfo({
    required this.birthday,
    required this.firstName,
    required this.email,
    required this.intro,
    required this.lastName,
    required this.location,
    required this.meetingType,
    required this.phone,
    required this.privateNotes,
    required this.profilePictureUrl,
    required this.publicPresentation,
    required this.specializations,
    required this.spokenLanguages,
    required this.professionalCertificates,
    required this.title,
    required this.userInfoIsVerified,
  });

  factory TherapistInfo.fromJson(Map<String, dynamic> json) {
    try {
      return TherapistInfo(
        birthday: json['birthday'] as Timestamp,
        firstName: json['firstName'] as String,
        intro: json['intro'] as String,
        lastName: json['lastName'] as String,
        email: json['email'] as String,
        location: Location.fromJson(json['location'] as Map<String, dynamic>),
        meetingType:
            MeetingType.fromJson(json['meetingType'] as Map<String, dynamic>),
        phone: Phone.fromJson(json['phone'] as Map<String, dynamic>),
        privateNotes: json['privateNotes'] as String,
        profilePictureUrl: ProfilePictureUrl.fromJson(
            json['profilePictureUrl'] as Map<String, dynamic>),
        publicPresentation: json['publicPresentation'] as String,
        specializations: List<String>.from(json['specializations'] as List),
        spokenLanguages: List<String>.from(json['spokenLanguages'] as List),
        professionalCertificates: (json['professionalCertificates'] as List)
            .map((i) =>
                ProfessionalCertificate.fromJson(i as Map<String, dynamic>))
            .toList(),
        title: json['title'] as String,
        userInfoIsVerified: json['userInfoIsVerified'] as bool,
      );
    } catch (e, stack) {
      debugPrint('Error in TherapistInfo.fromJson for ID ${json['id']}: $e');
      debugPrint('Stack trace: $stack');
      throw e;
    }
  }

  Map<String, dynamic> toJson() {
    return {
      'birthday': birthday,
      'firstName': firstName,
      'email': email,
      'intro': intro,
      'lastName': lastName,
      'location': location.toJson(),
      'meetingType': meetingType.toJson(),
      'phone': phone.toJson(),
      'privateNotes': privateNotes,
      'profilePictureUrl': profilePictureUrl.toJson(),
      'publicPresentation': publicPresentation,
      'specializations': specializations,
      'spokenLanguages': spokenLanguages,
      'professionalCertificates':
          professionalCertificates.map((i) => i.toJson()).toList(),
      'title': title,
      'userInfoIsVerified': userInfoIsVerified,
    };
  }
}

class Location {
  String address;
  String city;
  String country;
  GeoPoint geolocation;
  String stateProvince;
  String zip;

  Location({
    required this.address,
    required this.city,
    required this.country,
    required this.geolocation,
    required this.stateProvince,
    required this.zip,
  });

  factory Location.fromJson(Map<String, dynamic> json) {
    try {
      return Location(
        address: json['address'] as String,
        city: json['city'] as String,
        country: json['country'] as String,
        geolocation: json['geolocation'] as GeoPoint,
        stateProvince: json['stateProvince'] as String,
        zip: json['zip'] as String,
      );
    } catch (e, stack) {
      debugPrint('Error in Location.fromJson: $e');
      debugPrint('Stack trace: $stack');
      throw e;
    }
  }

  Map<String, dynamic> toJson() {
    return {
      'address': address,
      'city': city,
      'country': country,
      'geolocation': geolocation,
      'stateProvince': stateProvince,
      'zip': zip,
    };
  }
}

class MeetingType {
  bool presential;
  bool remote;

  MeetingType({
    required this.presential,
    required this.remote,
  });

  factory MeetingType.fromJson(Map<String, dynamic> json) {
    try {
      return MeetingType(
        presential: json['presential'] as bool,
        remote: json['remote'] as bool,
      );
    } catch (e, stack) {
      debugPrint('Error in MeetingType.fromJson: $e');
      debugPrint('Stack trace: $stack');
      throw e;
    }
  }

  Map<String, dynamic> toJson() {
    return {
      'presential': presential,
      'remote': remote,
    };
  }
}

class Phone {
  String areaCode;
  String number;

  Phone({
    required this.areaCode,
    required this.number,
  });

  factory Phone.fromJson(Map<String, dynamic> json) {
    try {
      return Phone(
        areaCode: json['areaCode'] as String,
        number: json['number'] as String,
      );
    } catch (e, stack) {
      debugPrint('Error in Phone.fromJson: $e');
      debugPrint('Stack trace: $stack');
      throw e;
    }
  }

  Map<String, dynamic> toJson() {
    return {
      'areaCode': areaCode,
      'number': number,
    };
  }
}

class ProfessionalCertificate {
  String institution;
  String photoUrl;
  String title;
  String type;
  bool verified;
  int yearObtained;

  ProfessionalCertificate({
    required this.institution,
    required this.photoUrl,
    required this.title,
    required this.type,
    required this.verified,
    required this.yearObtained,
  });

  factory ProfessionalCertificate.fromJson(Map<String, dynamic> json) {
    try {
      return ProfessionalCertificate(
        institution: json['institution'] as String,
        photoUrl: json['photoUrl'] as String,
        title: json['title'] as String,
        type: json['type'] as String,
        verified: json['verified'] as bool,
        yearObtained: json['yearObtained'] as int,
      );
    } catch (e, stack) {
      debugPrint('Error in ProfessionalCertificate.fromJson: $e');
      debugPrint('Stack trace: $stack');
      throw e;
    }
  }

  Map<String, dynamic> toJson() {
    return {
      'institution': institution,
      'photoUrl': photoUrl,
      'title': title,
      'type': type,
      'verified': verified,
      'yearObtained': yearObtained,
    };
  }
}

class ProfilePictureUrl {
  String large;
  String small;
  String thumb;

  ProfilePictureUrl({
    required this.large,
    required this.small,
    required this.thumb,
  });

  factory ProfilePictureUrl.fromJson(Map<String, dynamic> json) {
    try {
      return ProfilePictureUrl(
        large: json['large'] as String,
        small: json['small'] as String,
        thumb: json['thumb'] as String,
      );
    } catch (e, stack) {
      debugPrint('Error in ProfilePictureUrl.fromJson: $e');
      debugPrint('Stack trace: $stack');
      throw e;
    }
  }

  Map<String, dynamic> toJson() {
    return {
      'large': large,
      'small': small,
      'thumb': thumb,
    };
  }
}

Future<List<TherapistModel>> _fetchTherapists() async {
  try {
    FirebaseFirestore firestore = FirebaseFirestore.instance;
    QuerySnapshot snapshot = await firestore.collection('therapists').get();
    return snapshot.docs
        .map((doc) {
          try {
            return TherapistModel.fromJson(
              doc.data() as Map<String, dynamic>,
              doc.id,
            );
          } catch (e, stack) {
            debugPrint('Error in processing document ID ${doc.id}: $e');
            debugPrint('Stack trace: $stack');
            return null;
          }
        })
        .where((doc) => doc != null)
        .cast<TherapistModel>()
        .toList();
  } catch (e, stack) {
    debugPrint('Failed to get therapists: $e');
    debugPrint('Stack trace: $stack');
    return [];
  }
}

///// lib/screens/user_area/user_request_screen/user_request_screen.dart /////
import 'dart:async';
import 'dart:developer';

import 'package:country_picker/country_picker.dart';

import 'package:dash_flags/dash_flags.dart' as dash_flags;
import 'package:findatherapistapp/widgets/ModalTopChip/modal_top_chip.dart';
import 'package:findatherapistapp/widgets/NotificationModal/notification_modal.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:findatherapistapp/models/general_models.dart';
import 'package:findatherapistapp/providers/locale_provider.dart';
import 'package:findatherapistapp/utils/admin/to_capital_case.dart';
import 'package:findatherapistapp/widgets/NotificationSnackbar/notification_snackbar.dart';

import 'package:flutter_localized_locales/flutter_localized_locales.dart';
import 'package:findatherapistapp/widgets/LoadingCircle/loading_circle.dart';
import 'package:findatherapistapp/services/gemini_service.dart';
import 'package:findatherapistapp/services/speech_to_text_service.dart';

import 'package:go_router/go_router.dart';
import '../../../app_settings/theme_settings.dart';
import '../../../models/gemini_tags_response_model.dart';
import '../../../providers/providers_all.dart';
import '../../../routes/routes.dart';
import '../../../utils/debug/error_code_to_text.dart';
import '../../../utils/functions/show_city_state_selection_modal.dart';
import '../../../utils/locale/build_language_text_with_flag.dart';
import '../../../utils/locale/get_localized_language_names.dart';
import '../../../utils/locale/show_language_selection_modal.dart';
import '../../../utils/ui/get_dash_flag_by_country_code.dart';
import '../../../widgets/AppScaffold/app_scaffold.dart';
import '../../../generated/l10n.dart';
import '../../../widgets/LocationSelectionModal/location_selection_modal.dart';
import '../../common/aspects_screen/aspects_screen.dart';

class UserRequestScreen extends ConsumerStatefulWidget {
  const UserRequestScreen({super.key});

  @override
  ConsumerState<UserRequestScreen> createState() => _UserRequestScreenState();
}

class _UserRequestScreenState extends ConsumerState<UserRequestScreen> {
  final TextEditingController _requestController = TextEditingController();
  final TextEditingController _languageController = TextEditingController();
  String _requestLastText = '';
  final GeminiService _geminiService = GeminiService();
  final SpeechToTextService _speechService = SpeechToTextService();
  GeminiTagsResponse? _tagsResponse;
  bool isSendingRequest = false;
  bool _isListening = false;
  bool _isImprovingTranscription = false;
  bool _isAutoWriting = false;
  Timer? _autoWriteTimer;
  TextEditingController countryInputController = TextEditingController();
  TextEditingController stateProvinceInputController = TextEditingController();
  TextEditingController cityInputController = TextEditingController();

  String? defaultCountry;
  late UserRequestFilters therapistFilters;

  List<Country> countries = [];
  String listenedText = '';

  final ScrollController _scrollControllerPage1 = ScrollController();
  final ScrollController _scrollControllerPage2 = ScrollController();

  CountryService countryService = CountryService();

  List<String> selectedLanguages = ['en'];

  final PageController _pageController = PageController();

  @override
  void initState() {
    super.initState();
    _initializeSpeech();

    Locale currentLocale = ref.read(localeProvider).locale;

    selectedLanguages = [currentLocale.languageCode];

    therapistFilters = UserRequestFilters(
        remote: true,
        presential: true,
        location: LocationFilters(
            enabled: true, country: 'AU', state: null, city: null));
    List<Country> allCountries = countryService.getAll();

    setState(() {
      countries = allCountries;
    });

    stateProvinceInputController.text = '';
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    _languageController.text =
        getLocalizedLanguagesNames(context, languageCodes: selectedLanguages);
    if (therapistFilters.location.country == null) {
      countryInputController.text = '< Select a country >';
    } else {
      countryInputController.text =
          ' ${CountryLocalizations.of(context)?.countryName(countryCode: therapistFilters.location.country)}';
    }
  }

  void _initializeSpeech() async {
    await _speechService.initialize();
  }

  @override
  void dispose() {
    _speechService.stopListening();
    _requestController.dispose();
    _autoWriteTimer?.cancel();
    _pageController.dispose();
    super.dispose();
  }

  void _startAutoWrite() async {
    if (_isListening) {
      _stopListening();
    }
    setState(() {
      _isAutoWriting = true;
    });

    final LocaleProvider localeService = ref.read(localeProvider);

    final newText = await _geminiService.generateAutoWriteText(
        language: localeService.locale.languageCode);
    int charIndex = 0;
    int blockSize = 1;

    _autoWriteTimer = Timer.periodic(const Duration(milliseconds: 20), (timer) {
      if (_isAutoWriting && charIndex < newText.length) {
        setState(() {
          int nextIndex = charIndex + blockSize;
          if (nextIndex > newText.length) {
            nextIndex = newText.length;
          }
          _requestController.text += newText.substring(charIndex, nextIndex);
          charIndex = nextIndex;
        });
      } else {
        _stopAutoWrite();
      }
    });
  }

  void _stopAutoWrite() async {
    setState(() {
      _isAutoWriting = false;
    });
    _autoWriteTimer?.cancel();
  }

  void _startListening() async {
    if (_isAutoWriting) {
      _stopAutoWrite();
    }

    var localeService = ref.watch(localeProvider);

    setState(() {
      _isListening = true;
      _requestLastText = _requestController.text;
    });

    _speechService.startListening(
      localeId: localeService.locale.languageCode,
      onResult: (text) {
        setState(() {
          listenedText = text;
          _requestController.text = _requestLastText + text;
        });
      },
    );
    setState(() {
      listenedText = '';
    });
  }

  void _stopListening() async {
    _speechService.stopListening();
    setState(() => _isListening = false);

    if (_requestController.text.isNotEmpty && listenedText.isNotEmpty) {
      await _improveTranscription(_requestController.text);
    }
  }

  Future<void> _improveTranscription(String text) async {
    setState(() {
      _isImprovingTranscription = true;
    });

    final improvedText = await _geminiService.improveTranscription(text);
    setState(() {
      _requestController.text = improvedText;
      _isImprovingTranscription = false;
      _requestLastText = improvedText;
    });
  }

  @override
  Widget build(BuildContext context) {
    final bool isDarkMode =
        ref.watch(themeProvider).themeMode == ThemeMode.dark;

    final therapistsLanguages = ref.watch(therapistsLanguagesProvider);
    final labelTextStyle = Theme.of(context)
        .textTheme
        .titleMedium
        ?.copyWith(fontSize: 15, fontWeight: FontWeight.w600);

    return AppScaffold(
      scrollPhysics: const NeverScrollableScrollPhysics(),
      ignoreGlobalPadding: true,
      centerTitle: true,
      backButton: () {
        if (_pageController.hasClients && _pageController.page == 0) {
          if (Navigator.canPop(context)) {
            Navigator.pop(context);
          } else {
            context.go(Routes.welcomeMainScreen.path);
          }
        } else {
          _pageController.previousPage(
            duration: const Duration(milliseconds: 300),
            curve: Curves.easeInOut,
          );
        }
      },
      setFloatingSpeedDialToLoadingMode:
          isSendingRequest || _isAutoWriting || _isImprovingTranscription,
      useTopAppBar: true,
      isProtected: true,
      appBarTitle: S.of(context).yourRequest,
      body: Padding(
        padding: const EdgeInsets.only(left: 20, right: 20, bottom: 20),
        child: Column(
          children: [
            Expanded(
              child: PageView(
                controller: _pageController,
                physics: const ClampingScrollPhysics(),
                children: [
                  _buildFirstPage(
                      context, isDarkMode, therapistsLanguages.languages),
                  _buildSecondPage(context, isDarkMode),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildFirstPage(
      BuildContext context, bool isDarkMode, List<String> availableLanguages) {
    final screenHeight = MediaQuery.of(context).size.height;

    final labelTextStyle = Theme.of(context)
        .textTheme
        .titleMedium
        ?.copyWith(fontSize: 15, fontWeight: FontWeight.w600);

    return SingleChildScrollView(
      controller: _scrollControllerPage1,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: <Widget>[
          const SizedBox(
            height: 20,
          ),
          Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                '${S.of(context).meetingType}:',
                style: labelTextStyle,
              ),
              const SizedBox(height: 10),
              Row(
                children: [
                  Expanded(
                    child: ListTile(
                        dense: true,
                        onTap: () {
                          setState(() {
                            if (!therapistFilters.presential) return;

                            therapistFilters.remote = !therapistFilters.remote;
                          });
                        },
                        contentPadding: const EdgeInsets.only(
                            left: 16, right: 4, bottom: 1, top: 1),
                        shape: RoundedRectangleBorder(
                          side: BorderSide(
                            width: 1,
                            color: isDarkMode ? Colors.white : Colors.black87,
                          ),
                          borderRadius: ThemeSettings.buttonsBorderRadius,
                        ),
                        title: Text(S.of(context).remote,
                            style: Theme.of(context)
                                .textTheme
                                .bodyMedium
                                ?.copyWith(
                                  fontSize: 15,
                                )),
                        trailing: IgnorePointer(
                          child: Checkbox(
                              value: therapistFilters.remote,
                              onChanged: (value) {}),
                        )),
                  ),
                  const SizedBox(width: 10),
                  Expanded(
                    child: ListTile(
                        dense: true,
                        onTap: () {
                          setState(() {
                            if (!therapistFilters.remote) return;
                            therapistFilters.presential =
                                !therapistFilters.presential;
                          });
                        },
                        contentPadding: const EdgeInsets.only(
                            left: 16, right: 4, bottom: 1, top: 1),
                        shape: RoundedRectangleBorder(
                          side: BorderSide(
                            width: 1,
                            color: isDarkMode ? Colors.white : Colors.black87,
                          ),
                          borderRadius: ThemeSettings.buttonsBorderRadius,
                        ),
                        title: Text(S.of(context).presential,
                            overflow: TextOverflow.visible,
                            style: Theme.of(context)
                                .textTheme
                                .bodyMedium
                                ?.copyWith(fontSize: 15)),
                        trailing: IgnorePointer(
                          child: Checkbox(
                              value: therapistFilters.presential,
                              onChanged: (value) {}),
                        )),
                  ),
                ],
              ),
              const SizedBox(height: 12),

              /// Preferred Language Input
              Text(
                '${S.of(context).preferredLanguage}:',
                style: labelTextStyle,
              ),
              const SizedBox(height: 10),
              GestureDetector(
                onTap: () => showLanguageSelectionModal(context,
                    selectedLanguages: availableLanguages,
                    onLanguagesSelected: (List<String> languages) {
                  setState(() {
                    selectedLanguages = languages;
                    _languageController.text = getLocalizedLanguagesNames(
                        context,
                        languageCodes: selectedLanguages);
                  });
                }),
                child: AbsorbPointer(
                  child: Container(
                    width: double.infinity,
                    padding: const EdgeInsets.symmetric(
                        vertical: 13, horizontal: 12),
                    decoration: BoxDecoration(
                      color: isDarkMode
                          ? ThemeSettings.inputBackgroundColor.darkModePrimary
                          : ThemeSettings.inputBackgroundColor.lightModePrimary,
                      border: Border.all(
                          color: isDarkMode
                              ? ThemeSettings.primaryTextColor.darkModePrimary
                              : ThemeSettings
                                  .primaryTextColor.lightModePrimary),
                      borderRadius: ThemeSettings.inputsBorderRadius,
                    ),
                    child: Row(
                      mainAxisAlignment: MainAxisAlignment.spaceBetween,
                      children: [
                        Flexible(
                            child: buildLanguageText(context,
                                selectedLanguages: selectedLanguages)),
                        const Icon(Icons.add, size: 23),
                      ],
                    ),
                  ),
                ),
              ),
              const SizedBox(height: 10),
              Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Row(
                    children: [
                      Text(
                        '${S.of(context).location}:',
                        style: labelTextStyle,
                      ),
                      Expanded(
                        child: Row(
                            mainAxisAlignment: MainAxisAlignment.end,
                            children: [
                              Checkbox(
                                  value: !therapistFilters.location.enabled,
                                  onChanged: (_) {
                                    setState(() {
                                      therapistFilters.location.enabled =
                                          !therapistFilters.location.enabled;
                                    });
                                  }),
                              GestureDetector(
                                onTap: () {
                                  setState(() {
                                    therapistFilters.location.enabled =
                                        !therapistFilters.location.enabled;
                                  });
                                },
                                child: Text('${S.of(context).worldwide}  🌐',
                                    style: Theme.of(context)
                                        .textTheme
                                        .bodyMedium
                                        ?.copyWith(fontSize: 16)),
                              ),
                            ]),
                      ),
                    ],
                  ),

                  /// Country Input
                  Visibility(
                    visible: therapistFilters.location.enabled,
                    child: GestureDetector(
                      onTap: () {
                        showCountryPicker(
                          context: context,
                          showPhoneCode: false,
                          favorite: defaultCountry != null
                              ? [therapistFilters.location.country!]
                              : null,
                          countryListTheme: CountryListThemeData(
                            bottomSheetHeight: screenHeight * 0.85,
                            textStyle:
                                const TextStyle(height: 2, fontSize: 16.5),
                          ),
                          customFlagBuilder: (Country country) {
                            return getDashFlagByCountryCode(
                                country.countryCode);
                          },
                          onSelect: (Country country) {
                            setState(() {
                              if (therapistFilters.location.country !=
                                  country.countryCode) {
                                therapistFilters.location.state = null;
                                therapistFilters.location.city = null;
                                stateProvinceInputController.clear();
                                cityInputController.clear();
                              }

                              therapistFilters.location.country =
                                  country.countryCode;

                              countryInputController.text =
                                  '  ${country.nameLocalized}';
                              defaultCountry = country.countryCode;
                            });
                          },
                        );
                      },
                      child: AbsorbPointer(
                        child: Column(
                          mainAxisAlignment: MainAxisAlignment.center,
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            const SizedBox(height: 4),
                            TextField(
                              decoration: InputDecoration(
                                label: Text(S.of(context).country),
                                hintText: '< ${S.of(context).selectACountry} >',
                                hintStyle: Theme.of(context)
                                    .textTheme
                                    .titleMedium
                                    ?.copyWith(),
                                prefixIcon: Padding(
                                  padding: const EdgeInsets.only(left: 15),
                                  child: getDashFlagByCountryCode(
                                      therapistFilters.location.country),
                                ),
                                prefixIconConstraints: const BoxConstraints(
                                  minWidth: 41,
                                  minHeight: 20,
                                ),
                              ),
                              controller: countryInputController,
                            ),
                          ],
                        ),
                      ),
                    ),
                  ),
                  const SizedBox(height: 8),

                  /// State/Province Input
                  Visibility(
                    visible: therapistFilters.location.enabled,
                    child: GestureDetector(
                      onTap: () {
                        showCityStateSelectionModal(
                          context,
                          type: 'state',
                          country: therapistFilters.location.country!,
                          onSelect: (selectedItem) {
                            setState(() {
                              therapistFilters.location.state =
                                  selectedItem.isoCode;
                              stateProvinceInputController.text =
                                  selectedItem.name;
                              therapistFilters.location.city = null;
                              cityInputController.clear();
                            });
                          },
                        );
                      },
                      child: AbsorbPointer(
                        child: Column(
                          mainAxisAlignment: MainAxisAlignment.center,
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            const SizedBox(height: 15),
                            TextField(
                              textAlign: therapistFilters.location.state == null
                                  ? TextAlign.center
                                  : TextAlign.start,
                              decoration: InputDecoration(
                                filled: therapistFilters.location.state == null
                                    ? false
                                    : true,
                                floatingLabelBehavior:
                                    FloatingLabelBehavior.always,
                                label: Text(S.of(context).stateProvince),
                                hintText: '< ${S.of(context).all} >',
                                hintStyle: Theme.of(context)
                                    .textTheme
                                    .titleMedium
                                    ?.copyWith(
                                      fontSize: 15,
                                    ),
                                border: const OutlineInputBorder(),
                              ),
                              controller: stateProvinceInputController,
                              onChanged: (value) {
                                if (value.isEmpty) {
                                  therapistFilters.location.state = null;
                                }
                              },
                            ),
                          ],
                        ),
                      ),
                    ),
                  ),
                  const SizedBox(height: 8),

                  /// City Input
                  Visibility(
                    visible: therapistFilters.location.enabled &&
                        therapistFilters.location.state != null,
                    child: GestureDetector(
                      onTap: () {
                        showCityStateSelectionModal(
                          context,
                          type: 'city',
                          country: therapistFilters.location.country!,
                          state: therapistFilters.location.state,
                          onSelect: (selectedItem) {
                            setState(() {
                              therapistFilters.location.city =
                                  selectedItem.name;
                              cityInputController.text = selectedItem.name;
                            });
                          },
                        );
                      },
                      child: AbsorbPointer(
                        child: Column(
                          mainAxisAlignment: MainAxisAlignment.center,
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            const SizedBox(height: 15),
                            TextField(
                              textAlign: therapistFilters.location.city == null
                                  ? TextAlign.center
                                  : TextAlign.start,
                              decoration: InputDecoration(
                                floatingLabelBehavior:
                                    FloatingLabelBehavior.always,
                                label: Text(S.of(context).city),
                                hintText: '< ${S.of(context).all} >',
                                hintStyle: Theme.of(context)
                                    .textTheme
                                    .titleMedium
                                    ?.copyWith(fontSize: 15),
                                border: const OutlineInputBorder(),
                              ),
                              controller:
                                  cityInputController, // Usar el nuevo controlador
                            ),
                            const SizedBox(height: 12),
                          ],
                        ),
                      ),
                    ),
                  ),
                ],
              ),
            ],
          ),
          const SizedBox(height: 10),

          /// Next Button
          Row(
            mainAxisAlignment: MainAxisAlignment.end,
            children: <Widget>[
              ElevatedButton(
                iconAlignment: IconAlignment.end,
                style: ElevatedButton.styleFrom(
                  padding: const EdgeInsets.only(right: 10, left: 20),
                  minimumSize: const Size(120, ThemeSettings.buttonsHeight),
                ),
                onPressed: () {
                  _pageController.nextPage(
                    duration: const Duration(milliseconds: 300),
                    curve: Curves.easeInOut,
                  );
                },
                child: Row(
                  children: [
                    Text(S.of(context).continueButton),
                    const SizedBox(width: 10),
                    const Icon(Icons.arrow_forward_ios, size: 16)
                  ],
                ),
              ),
            ],
          ),
          const SizedBox(height: 90),
        ],
      ),
    );
  }

  Widget _buildSecondPage(BuildContext context, bool isDarkMode) {
    return SingleChildScrollView(
      controller: _scrollControllerPage2,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: <Widget>[
          const SizedBox(
            height: 20,
          ),
          Text(S.of(context).tellUsWhatYouAreLookingFor,
              style: Theme.of(context)
                  .textTheme
                  .titleMedium
                  ?.copyWith(fontSize: 17)),
          const SizedBox(height: 20),

          Stack(
            children: [
              Scrollbar(
                thumbVisibility: true,
                thickness: 5,
                controller: _scrollControllerPage2,
                child: TextField(
                  scrollPhysics: const ClampingScrollPhysics(),
                  controller: _requestController,
                  decoration: InputDecoration(
                    hintText: S.of(context).requestTextFieldHintText,
                    border: const OutlineInputBorder(),
                  ),
                  maxLines: 18,
                  enabled: !isSendingRequest &&
                      !_isImprovingTranscription &&
                      !_isAutoWriting,
                ),
              ),

              /// Auto Writting Icon
              Positioned(
                right: 58,
                bottom: 13,
                child: InkWell(
                    borderRadius: BorderRadius.circular(50),
                    onTap: _isAutoWriting ? _stopAutoWrite : _startAutoWrite,
                    child: Container(
                      padding: const EdgeInsets.all(10),
                      decoration: BoxDecoration(
                        color: _isAutoWriting && isDarkMode
                            ? Colors.white24
                            : Colors.transparent,
                        boxShadow: [
                          if (_isAutoWriting)
                            BoxShadow(
                              color: Colors.black.withOpacity(0.2),
                              blurRadius: 0,
                              spreadRadius: 0,
                            ),
                        ],
                        shape: BoxShape.circle,
                      ),
                      child: Icon(
                        _isAutoWriting
                            ? Icons.auto_awesome
                            : Icons.auto_awesome_outlined,
                        color: (isSendingRequest && !isDarkMode)
                            ? Colors.black54
                            : (isSendingRequest && isDarkMode)
                                ? Colors.white24
                                : (_isAutoWriting && !isDarkMode
                                    ? Colors.yellow
                                    : isDarkMode && _isAutoWriting
                                        ? Colors.white
                                        : isDarkMode && !_isAutoWriting
                                            ? Colors.white.withOpacity(0.7)
                                            : Colors.black.withOpacity(0.7)),
                        size: 28,
                      ),
                    )),
              ),

              /// Record Icon
              Positioned(
                right: 13,
                bottom: 13,
                child: InkWell(
                    borderRadius: BorderRadius.circular(50),
                    onTap: isSendingRequest
                        ? null
                        : (_isListening ? _stopListening : _startListening),
                    child: Container(
                      padding: const EdgeInsets.all(10),
                      decoration: BoxDecoration(
                        color: _isListening ? Colors.red : Colors.transparent,
                        shape: BoxShape.circle,
                      ),
                      child: Icon(
                        _isListening ? Icons.mic : Icons.mic_none,
                        color: (isSendingRequest && !isDarkMode)
                            ? Colors.black54
                            : (isSendingRequest && isDarkMode)
                                ? Colors.white24
                                : (_isListening && !isDarkMode
                                    ? Colors.white
                                    : isDarkMode && _isListening
                                        ? Colors.white
                                        : isDarkMode && !_isListening
                                            ? Colors.white.withOpacity(0.7)
                                            : Colors.black.withOpacity(0.7)),
                        size: 30,
                      ),
                    )),
              ),
            ],
          ),
          const SizedBox(height: 15),

          if (_tagsResponse != null) ...[
            if (_tagsResponse!.error != null) ...[
              Container(
                width: double.infinity,
                decoration: BoxDecoration(
                  color: ThemeSettings.errorColor.shade50,
                  border: Border.all(
                    color: ThemeSettings.errorColor,
                  ),
                ),
                child: Padding(
                  padding: const EdgeInsets.all(12.0),
                  child: Column(
                    children: [
                      const SizedBox(height: 10),
                      const Icon(Icons.warning, color: Colors.red, size: 40),
                      const SizedBox(height: 10),
                      Text(
                        S.of(context).ohNoSomethingWentWrong,
                        textAlign: TextAlign.center,
                        style:
                            Theme.of(context).textTheme.headlineSmall?.copyWith(
                                  color: ThemeSettings.errorColor,
                                ),
                      ),
                      const SizedBox(height: 10),
                      Text(
                        ErrorCodeToText.getGeminiErrorMessage(
                            _tagsResponse!.error!, context),
                        textAlign: TextAlign.center,
                        style: Theme.of(context).textTheme.bodyLarge?.copyWith(
                              color: ThemeSettings.errorColor,
                            ),
                      ),
                      const SizedBox(height: 10),
                    ],
                  ),
                ),
              ),
              const SizedBox(height: 12),
            ],
          ],

          /// Send Button
          Row(
            mainAxisAlignment: MainAxisAlignment.end,
            children: <Widget>[
              ElevatedButton(
                  style: ElevatedButton.styleFrom(
                    minimumSize: const Size(120, ThemeSettings.buttonsHeight),
                  ),
                  onPressed: isSendingRequest || _isAutoWriting
                      ? null
                      : _sendUserRequest,
                  child: isSendingRequest
                      ? Text(S.of(context).sendingButton)
                      : _isListening ||
                              _isImprovingTranscription ||
                              _isAutoWriting
                          ? SizedBox(
                              height: 20,
                              width: 20,
                              child: LoadingCircle(
                                color: isDarkMode
                                    ? Colors.white.withOpacity(0.8)
                                    : Colors.white.withOpacity(0.8),
                              ),
                            )
                          : Text(S.of(context).sendButton)),
            ],
          ),
          const SizedBox(height: 50),
        ],
      ),
    );
  }
  //
  // void showLanguageSelectionModal(
  //     BuildContext context, List<String> availableLanguages) {
  //   showModalBottomSheet(
  //     isScrollControlled: true,
  //     constraints: BoxConstraints(
  //       maxHeight: MediaQuery.of(context).size.height * 0.8,
  //     ),
  //     context: context,
  //     builder: (BuildContext context) {
  //       return Column(
  //         mainAxisAlignment: MainAxisAlignment.end,
  //         mainAxisSize: MainAxisSize.min,
  //         children: [
  //           const ModalTopChip(),
  //           StatefulBuilder(
  //             builder: (BuildContext context, StateSetter modalSetState) {
  //               return Expanded(
  //                 child: Padding(
  //                   padding: const EdgeInsets.only(
  //                       top: 10, bottom: 30, left: 10, right: 10),
  //                   child: SingleChildScrollView(
  //                     physics: const ClampingScrollPhysics(),
  //                     child: Column(
  //                       mainAxisSize: MainAxisSize.min,
  //                       children: availableLanguages.map((String languageCode) {
  //                         return CheckboxListTile(
  //                           title: Row(
  //                             children: [
  //                               dash_flags.LanguageFlag(
  //                                   height: 20,
  //                                   language: dash_flags.Language.fromCode(
  //                                       languageCode)),
  //                               const SizedBox(width: 10),
  //                               Text(LocaleNames.of(context)!
  //                                           .nameOf(languageCode) !=
  //                                       null
  //                                   ? toCapitalCase(LocaleNames.of(context)!
  //                                       .nameOf(languageCode)!)
  //                                   : languageCode),
  //                             ],
  //                           ),
  //                           value: selectedLanguages.contains(languageCode),
  //                           onChanged: (bool? value) {
  //                             modalSetState(() {
  //                               if (value == true) {
  //                                 selectedLanguages.add(languageCode);
  //                               } else {
  //                                 if (selectedLanguages.length > 1) {
  //                                   selectedLanguages.remove(languageCode);
  //                                 }
  //                               }
  //                             });
  //                             setState(() {
  //                               _languageController.text =
  //                                   getLocalizedLanguagesNames(context,
  //                                       languageCodes: selectedLanguages);
  //                             });
  //                           },
  //                         );
  //                       }).toList(),
  //                     ),
  //                   ),
  //                 ),
  //               );
  //             },
  //           ),
  //         ],
  //       );
  //     },
  //   );
  // }

  Future<Object?> _sendUserRequest() async {
    if (isSendingRequest) return null;
    if (_requestController.text.isEmpty) {
      NotificationSnackbar.showSnackBar(
          message: S.of(context).theRequestInputShouldNotBeEmpty,
          variant: SnackbarVariant.info,
          duration: 'short');
      return null;
    }

    setState(() {
      isSendingRequest = true;
    });
    final inputText = _requestController.text;
    final GeminiTagsResponse geminiResponse =
        await _geminiService.getTherapyTags(inputText);

    if (geminiResponse.tags.positive.isEmpty &&
        geminiResponse.tags.negative.isEmpty) {
      if (mounted) {
        NotificationModal.errorModal(
            context: context,
            title: S.of(context).oops,
            message: S.of(context).noTagsFoundErrorDescription,
            onTapConfirm: () {});
      }

      setState(() {
        isSendingRequest = false;
      });
      return null;
    }

    setState(() {
      _tagsResponse = geminiResponse;
    });

    log(geminiResponse.toJson().toString());

    if (geminiResponse.error != null) {
      setState(() {
        isSendingRequest = false;
      });
      return null;
    }

    if (mounted) {
      Navigator.push(
        context,
        MaterialPageRoute(
          builder: (context) => AspectsScreen(
            aspects: geminiResponse.tags.toAspects(),
            therapistFilters: therapistFilters,
          ),
        ),
      );
    }

    setState(() {
      isSendingRequest = false;
    });

    return geminiResponse;
  }
}

///// lib/screens/therapist_area/therapist_personal_profile_screen/therapist_personal_profile_screen.dart /////
import 'dart:io';
import 'package:advanced_chips_input/advanced_chips_input.dart';
import 'package:animate_do/animate_do.dart';
import 'package:cached_network_image/cached_network_image.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:country_state_city/models/city.dart';
import 'package:country_state_city/models/state.dart' as state_utils;
import 'package:country_state_city/utils/state_utils.dart';
import 'package:findatherapistapp/services/firestore_service.dart';
import 'package:findatherapistapp/widgets/LoadingCircle/loading_circle.dart';
import 'package:findatherapistapp/widgets/NotificationModal/notification_modal.dart';
import 'package:findatherapistapp/widgets/NotificationSnackbar/notification_snackbar.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:image_picker/image_picker.dart';
import 'package:findatherapistapp/widgets/AppScaffold/app_scaffold.dart';
import 'package:findatherapistapp/app_settings/theme_settings.dart';
import 'package:findatherapistapp/providers/providers_all.dart';
import 'package:findatherapistapp/providers/therapist_provider.dart';
import 'package:findatherapistapp/routes/routes.dart';
import 'package:findatherapistapp/services/profile_service.dart';
import 'package:country_picker/country_picker.dart';
import '../../../generated/l10n.dart';
import '../../../utils/functions/profile_utils.dart';
import '../../../utils/functions/show_city_state_selection_modal.dart';
import '../../../utils/locale/all_locales_list.dart';
import '../../../utils/locale/build_language_text_with_flag.dart';
import '../../../utils/locale/get_localized_language_names.dart';
import '../../../utils/locale/show_language_selection_modal.dart';
import '../../../utils/ui/get_dash_flag_by_country_code.dart';

class TherapistPersonalProfileScreen extends ConsumerStatefulWidget {
  const TherapistPersonalProfileScreen({super.key});

  @override
  ConsumerState<TherapistPersonalProfileScreen> createState() =>
      _TherapistPersonalProfileScreenState();
}

class _TherapistPersonalProfileScreenState
    extends ConsumerState<TherapistPersonalProfileScreen>
    with SingleTickerProviderStateMixin {
  final _formKey = GlobalKey<FormState>();

  late String? therapistId;
  final TextEditingController _titleController = TextEditingController();
  final TextEditingController _firstNameController = TextEditingController();
  final TextEditingController _lastNameController = TextEditingController();
  final TextEditingController _emailController = TextEditingController();
  final TextEditingController _phoneController = TextEditingController();
  final TextEditingController _phoneAreaCodeController =
      TextEditingController();
  final TextEditingController _introController = TextEditingController();
  final TextEditingController _publicPresentationController =
      TextEditingController();
  final TextEditingController _privateNotesController = TextEditingController();
  final TextEditingController _addressController = TextEditingController();
  final TextEditingController _cityCodeController = TextEditingController();
  final TextEditingController _countryCodeController = TextEditingController();
  final TextEditingController _stateProvinceCodeController =
      TextEditingController();
  final TextEditingController countryNameController = TextEditingController();
  final TextEditingController stateProvinceNameController =
      TextEditingController();
  final TextEditingController cityNameController = TextEditingController();

  final TextEditingController _zipController = TextEditingController();
  final TextEditingController _profilePictureUrlController =
      TextEditingController();

  final TextEditingController _specializationsController =
      TextEditingController();

  TextEditingController _languageController = TextEditingController();

  List<String> selectedLanguages = ['en'];
  List<String> _specializations = [];
  bool _presential = false;
  bool _remote = false;
  File? _selectedImage;
  bool uploadingProfilePicture = false;
  bool savingChanges = false;

  Timestamp therapistDateOfBirth = Timestamp.fromDate(DateTime(1990, 1, 1));
  GeoPoint therapistGeolocation = const GeoPoint(0, 0);

  late TabController _tabController;
  String? defaultCountry;

  @override
  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 2, vsync: this);

    selectedLanguages =
        ref.read(therapistProvider).therapist?.therapistInfo.spokenLanguages ??
            ['en'];
    // _languageController.text =
    //     getLocalizedLanguagesNames(context, languageCodes: selectedLanguages);
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();

    _languageController.text =
        getLocalizedLanguagesNames(context, languageCodes: selectedLanguages);
  }

  @override
  void dispose() {
    therapistId = null;
    _tabController.dispose();
    _firstNameController.dispose();
    _lastNameController.dispose();
    _emailController.dispose();
    _specializationsController.dispose();
    _phoneController.dispose();
    _languageController.dispose();
    _introController.dispose();
    _publicPresentationController.dispose();
    _privateNotesController.dispose();
    _addressController.dispose();
    _cityCodeController.dispose();
    _countryCodeController.dispose();
    _stateProvinceCodeController.dispose();
    cityNameController.dispose();
    stateProvinceNameController.dispose();
    countryNameController.dispose();
    _zipController.dispose();
    _profilePictureUrlController.dispose();
    _titleController.dispose();

    super.dispose();
  }

  void _updateSelectedLanguages(List<String> languages) {
    setState(() {
      selectedLanguages = languages;
      _languageController.text =
          getLocalizedLanguagesNames(context, languageCodes: selectedLanguages);
    });
  }

  Future<void> _pickImageFromGallery() async {
    final imageFile = await pickImage(
      ImageSource.gallery,
    );

    if (imageFile != null) {
      setState(() {
        _selectedImage = imageFile;
      });

      if (mounted) {
        NotificationSnackbar.showSnackBar(
            message: S.of(context).imageUploadedSuccessfully,
            variant: 'success',
            duration: 'short');
      }

      final downloadUrl =
          await uploadProfilePicture(_selectedImage!, 'therapist');

      if (downloadUrl != null) {
        setState(() {
          _profilePictureUrlController.text = downloadUrl;
        });

        debugPrint('Image uploaded successfully');
      } else {
        debugPrint('Error uploading image');
      }
    }
  }

  Future<void> _pickImageFromCamera() async {
    final imageFile = await pickImage(ImageSource.camera,
        preferredCamera: CameraDevice.front);

    if (imageFile != null) {
      setState(() {
        _selectedImage = imageFile;
      });

      debugPrint('Image uploaded successfully');
      final downloadUrl =
          await uploadProfilePicture(_selectedImage!, 'therapist');

      if (downloadUrl != null) {
        setState(() {
          _profilePictureUrlController.text = downloadUrl;
        });

        NotificationSnackbar.showSnackBar(
            message: S.of(context).imageUploadedSuccessfully,
            variant: 'success',
            duration: 'short');
      }
    }
  }

  Future<void> _saveChanges() async {
    bool isDarkMode = ref.watch(themeProvider).themeMode == ThemeMode.dark;
    setState(() {
      savingChanges = true;
    });
    final profileService = ref.read(profileServiceProvider);

    final currentDoc = await FirestoreService.instance
        .collection('therapists')
        .doc(therapistId)
        .get();
    final currentData = currentDoc.data() as Map<String, dynamic>;

    final Map<String, dynamic> updatedData = {
      'firstName': _firstNameController.text,
      'lastName': _lastNameController.text,
      'birthday': therapistDateOfBirth,
      'email': _emailController.text,
      'phone': {
        'number': _phoneController.text,
        'areaCode': _phoneAreaCodeController.text,
      },
      'intro': _introController.text,
      'publicPresentation': _publicPresentationController.text,
      'privateNotes': _privateNotesController.text,
      'location': {
        'address': _addressController.text,
        'city': _cityCodeController.text,
        'country': _countryCodeController.text,
        'stateProvince': stateProvinceNameController.text,
        'zip': _zipController.text,
        'geolocation': therapistGeolocation,
      },
      'specializations': _specializations,
      'spokenLanguages': selectedLanguages,
      'meetingType': {
        'presential': _presential,
        'remote': _remote,
      },
      'profilePictureUrl': {
        'large': _profilePictureUrlController.text,
        'small': '',
        'thumb': ''
      },
      'title': '',
      'userInfoIsVerified': false,
      'professionalCertificates':
          currentData['therapistInfo']['professionalCertificates'] ?? [],
    };

    try {
      bool therapistDataUploadedSuccesfully =
          await profileService.updateProfile(
        profileTarget: 'therapist',
        userId: therapistId!,
        data: {'therapistInfo': updatedData},
        profilePicture: _selectedImage,
      );

      if (therapistDataUploadedSuccesfully) {
        debugPrint('Profile updated successfully');

        ref.read(therapistProvider.notifier).updateTherapistInfo(updatedData);

        if (mounted) {
          NotificationModal.successfulModal(
            context: context,
            title: S.of(context).profileSaved,
            message: S.of(context).profileSavedMessage,
          );
        }
      } else {
        debugPrint('Error updating profile');
        if (mounted) {
          NotificationModal.errorModal(
            icon: isDarkMode ? Icons.error_outline : Icons.error,
            context: context,
            title: S.of(context).errorSavingProfile,
            message: S.of(context).errorSavingProfileMessage,
          );
        }
      }
    } catch (e) {
      debugPrint('Error updating profile: $e');
    }

    setState(() {
      savingChanges = false;
      _selectedImage = null;
    });
  }

  @override
  Widget build(BuildContext context) {
    final bool isDarkMode =
        ref.watch(themeProvider).themeMode == ThemeMode.dark;
    final therapistState = ref.watch(therapistProvider);
    final therapist = therapistState.therapist;
    final labelTextStyle = Theme.of(context)
        .textTheme
        .titleMedium
        ?.copyWith(fontSize: 15, fontWeight: FontWeight.w600);

    if (therapist == null) {
      return const Center(child: CircularProgressIndicator());
    }

    therapistId = therapist.id;

    if (_firstNameController.text.isEmpty) {
      _firstNameController.text = therapist.therapistInfo.firstName;
    }
    if (_lastNameController.text.isEmpty) {
      _lastNameController.text = therapist.therapistInfo.lastName;
    }

    if (_emailController.text.isEmpty) {
      _emailController.text = therapist.therapistInfo.email;
    }

    if (_phoneController.text.isEmpty) {
      _phoneController.text = therapist.therapistInfo.phone.number;
    }

    if (_phoneAreaCodeController.text.isEmpty) {
      _phoneAreaCodeController.text = therapist.therapistInfo.phone.areaCode;
    }

    if (_specializationsController.text.isEmpty) {
      _specializationsController.text = "Psichologist Counselor";
    }

    if (_introController.text.isEmpty) {
      _introController.text = therapist.therapistInfo.intro;
    }
    if (_publicPresentationController.text.isEmpty) {
      _publicPresentationController.text =
          therapist.therapistInfo.publicPresentation;
    }
    if (_privateNotesController.text.isEmpty) {
      _privateNotesController.text = therapist.therapistInfo.privateNotes;
    }

    if (_profilePictureUrlController.text.isEmpty) {
      _profilePictureUrlController.text =
          therapist.therapistInfo.profilePictureUrl.large;
    }

    if (_addressController.text.isEmpty) {
      _addressController.text = therapist.therapistInfo.location.address;
    }
    if (_cityCodeController.text.isEmpty) {
      _cityCodeController.text = therapist.therapistInfo.location.city;
    }
    if (_countryCodeController.text.isEmpty) {
      _countryCodeController.text = therapist.therapistInfo.location.country;
      countryNameController.text = CountryLocalizations.of(context)!
          .countryName(countryCode: therapist.therapistInfo.location.country)!;
    }
    if (_stateProvinceCodeController.text.isEmpty) {
      _stateProvinceCodeController.text =
          therapist.therapistInfo.location.stateProvince;

      stateProvinceNameController.text =
          therapist.therapistInfo.location.stateProvince;
    }

    if (therapistGeolocation.latitude == 0 &&
        therapistGeolocation.longitude == 0) {
      therapistGeolocation = therapist.therapistInfo.location.geolocation;
    }
    if (_zipController.text.isEmpty) {
      _zipController.text = therapist.therapistInfo.location.zip;
    }
    _presential = therapist.therapistInfo.meetingType.presential;
    _remote = therapist.therapistInfo.meetingType.remote;
    _specializations = therapist.therapistInfo.specializations;

    return AppScaffold(
      ignoreGlobalPadding: true,
      backButton: () {
        if (context.canPop()) {
          context.pop();
        } else {
          context.go(Routes.welcomeMainScreen.path);
        }
      },
      hideFloatingSpeedDialMenu: true,
      scrollPhysics: const NeverScrollableScrollPhysics(),
      appBarTitle: S.of(context).yourTherapistProfile,
      centerTitle: true,
      useTopAppBar: true,
      actions: [
        IconButton(
          icon: const Icon(Icons.settings),
          onPressed: () {
            context.push(Routes.settingsScreen.path);
          },
        ),
      ],
      isProtected: false,
      body: Column(
        children: [
          Expanded(
            child: NestedScrollView(
              headerSliverBuilder: (context, innerBoxIsScrolled) => [
                SliverAppBar(
                  backgroundColor: isDarkMode
                      ? ThemeSettings.scaffoldBackgroundColor.darkModePrimary
                      : ThemeSettings.scaffoldBackgroundColor.lightModePrimary,
                  surfaceTintColor: Color(0xFF4B4B4B),
                  leading: Container(),
                  expandedHeight: 220.0,
                  floating: true,
                  pinned: true,
                  flexibleSpace: LayoutBuilder(
                    builder:
                        (BuildContext context, BoxConstraints constraints) {
                      double top = constraints.biggest.height;
                      return Container(
                        decoration: BoxDecoration(
                          color: isDarkMode
                              ? ThemeSettings
                                  .scaffoldBackgroundColor.darkModePrimary
                              : ThemeSettings
                                  .scaffoldBackgroundColor.lightModePrimary,
                          boxShadow: [
                            if (innerBoxIsScrolled)
                              BoxShadow(
                                color: Colors.black.withOpacity(0.08),
                                blurRadius: 1.0,
                                offset: Offset(0, 0.8),
                              ),
                          ],
                        ),
                        child: FlexibleSpaceBar(
                          centerTitle: true,
                          background: Column(
                            children: [
                              const SizedBox(height: 20),
                              Stack(
                                fit: StackFit.loose,
                                alignment: Alignment.topCenter,
                                clipBehavior: Clip.none,
                                children: [
                                  FadeIn(
                                    delay: const Duration(milliseconds: 300),
                                    child: ClipOval(
                                      child: Material(
                                        color: Colors.transparent,
                                        child: InkWell(
                                          splashColor:
                                              Colors.black.withAlpha(30),
                                          onTap: _pickImageFromGallery,
                                          child: AnimatedContainer(
                                            clipBehavior: Clip.hardEdge,
                                            duration:
                                                Duration(milliseconds: 100),
                                            margin: EdgeInsets.only(
                                              top: top > 160.0 ? 0.0 : 17.0,
                                            ),
                                            width: top > 160.0 ? 140.0 : 80.0,
                                            height: top > 160.0 ? 140.0 : 80.0,
                                            decoration: BoxDecoration(
                                              boxShadow: [
                                                BoxShadow(
                                                  color: Colors.grey
                                                      .withOpacity(0.1),
                                                  blurRadius: 1,
                                                  offset: const Offset(0, 1),
                                                ),
                                              ],
                                              shape: BoxShape.circle,
                                              border: Border.all(
                                                color: Colors.white,
                                                width: 4,
                                              ),
                                            ),
                                            child: Ink(
                                              decoration: BoxDecoration(
                                                color: Colors.white,
                                                shape: BoxShape.circle,
                                                image: _selectedImage != null
                                                    ? DecorationImage(
                                                        image: AssetImage(
                                                          _selectedImage!.path,
                                                        ),
                                                        fit: BoxFit.cover,
                                                      )
                                                    : therapist
                                                            .therapistInfo
                                                            .profilePictureUrl
                                                            .large
                                                            .isEmpty
                                                        ? const DecorationImage(
                                                            image: AssetImage(
                                                              'lib/assets/placeholders/default_profile_picture.jpg',
                                                            ),
                                                            fit: BoxFit.cover,
                                                          )
                                                        : DecorationImage(
                                                            image:
                                                                CachedNetworkImageProvider(
                                                              therapist
                                                                  .therapistInfo
                                                                  .profilePictureUrl
                                                                  .large,
                                                            ),
                                                            fit: BoxFit.cover,
                                                          ),
                                              ),
                                            ),
                                          ),
                                        ),
                                      ),
                                    ),
                                  ),
                                  if (top > 160.0)
                                    Positioned(
                                      right: -4,
                                      top: 10,
                                      child: FadeIn(
                                        child: Container(
                                          padding: const EdgeInsets.all(0),
                                          width: 35,
                                          height: 35,
                                          decoration: const BoxDecoration(
                                            border: Border.fromBorderSide(
                                                BorderSide(
                                              color: Colors.black26,
                                              width: 3,
                                            )),
                                            color: Colors.white,
                                            shape: BoxShape.circle,
                                          ),
                                          child: Center(
                                            child: IconButton(
                                              padding: EdgeInsets.zero,
                                              icon: const Icon(
                                                Icons.camera_alt,
                                                size: 19,
                                              ),
                                              color: Colors.black54,
                                              onPressed: _pickImageFromCamera,
                                            ),
                                          ),
                                        ),
                                      ),
                                    ),
                                ],
                              ),
                            ],
                          ),
                        ),
                      );
                    },
                  ),
                  bottom: TabBar(
                    overlayColor:
                        WidgetStateProperty.all<Color>(Colors.transparent),
                    splashFactory: null,
                    controller: _tabController,
                    tabAlignment: TabAlignment.center,
                    indicator: BoxDecoration(
                        color: isDarkMode
                            ? ThemeSettings.primaryTextColor.darkModePrimary
                                .withOpacity(0.9)
                            : ThemeSettings.primaryTextColor.lightModePrimary
                                .withOpacity(0.8),
                        borderRadius: const BorderRadius.only(
                          bottomRight: Radius.circular(2),
                          bottomLeft: Radius.circular(2),
                          topLeft: Radius.circular(2),
                          topRight: Radius.circular(2),
                        )),
                    indicatorPadding: const EdgeInsets.only(top: 45),
                    indicatorColor: ThemeSettings.seedColor.withOpacity(0.7),
                    dividerColor: Colors.transparent,
                    labelStyle:
                        Theme.of(context).textTheme.titleMedium?.copyWith(
                              fontWeight: FontWeight.w600,
                            ),
                    labelPadding:
                        const EdgeInsets.symmetric(vertical: 0, horizontal: 12),
                    tabs: [
                      Tab(
                        text: S.of(context).contactInfo,
                      ),
                      Tab(text: S.of(context).aboutMe),
                    ],
                  ),
                ),
              ],
              body: TabBarView(
                controller: _tabController,
                children: [
                  // Personal Info Tab
                  SingleChildScrollView(
                    physics: const ClampingScrollPhysics(),
                    child: Padding(
                      padding: const EdgeInsets.symmetric(
                        horizontal: 18.0,
                        vertical: 16.0,
                      ),
                      child: Form(
                        key: _formKey,
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            // const SizedBox(height: 16),
                            // Text(
                            //   'Title',
                            //   style: labelTextStyle,
                            // ),
                            // const SizedBox(height: 8),
                            // TextFormField(
                            //   controller: _titleController,
                            // ),
                            const SizedBox(height: 16),
                            Text(
                              S.of(context).firstName,
                              style: labelTextStyle,
                            ),
                            const SizedBox(height: 8),
                            TextFormField(
                              controller: _firstNameController,
                              validator: (value) {
                                if (value == null || value.isEmpty) {
                                  return S.of(context).pleaseEnterYourFullName;
                                }
                                return null;
                              },
                            ),
                            const SizedBox(height: 10),
                            Text(
                              S.of(context).lastName,
                              style: labelTextStyle,
                            ),
                            const SizedBox(height: 8),
                            TextFormField(
                              controller: _lastNameController,
                              validator: (value) {
                                if (value == null || value.isEmpty) {
                                  return S.of(context).pleaseEnterYourFullName;
                                }
                                return null;
                              },
                            ),
                            const SizedBox(height: 10),
                            Text(
                              S.of(context).contactEmail,
                              style: labelTextStyle,
                            ),
                            const SizedBox(height: 8),
                            TextFormField(
                              controller: _emailController,
                              keyboardType: TextInputType.emailAddress,
                              validator: (value) {
                                if (value == null || value.isEmpty) {
                                  return S.of(context).pleaseEnterYourEmail;
                                }
                                return null;
                              },
                            ),
                            const SizedBox(height: 10),
                            Text(
                              S.of(context).phone,
                              style: labelTextStyle,
                            ),
                            Row(
                              mainAxisSize: MainAxisSize.max,
                              mainAxisAlignment: MainAxisAlignment.spaceBetween,
                              children: [
                                Container(
                                  constraints: const BoxConstraints(
                                    maxWidth: 80,
                                  ),
                                  child: TextFormField(
                                    controller: _phoneAreaCodeController,
                                    keyboardType: TextInputType.phone,
                                    inputFormatters: [
                                      LengthLimitingTextInputFormatter(4),
                                    ],
                                    decoration: const InputDecoration(
                                      hintText: '000',
                                      prefixIcon: Padding(
                                        padding: EdgeInsets.only(left: 10),
                                        child: Icon(
                                          Icons.add,
                                          size: 16,
                                        ),
                                      ),
                                      prefixIconConstraints: BoxConstraints(
                                        minWidth: 18,
                                      ),
                                    ),
                                    validator: (value) {
                                      if (value == null || value.isEmpty) {
                                        return S
                                            .of(context)
                                            .pleaseEnterPhoneAreaCode;
                                      }
                                      return null;
                                    },
                                  ),
                                ),
                                SizedBox(width: 10),
                                Expanded(
                                  child: TextFormField(
                                    controller: _phoneController,
                                    decoration: const InputDecoration(
                                      hintText: '000 000 0000',
                                    ),
                                    keyboardType: TextInputType.phone,
                                    validator: (value) {
                                      if (value == null || value.isEmpty) {
                                        return S
                                            .of(context)
                                            .pleaseEnterYourPhoneNumber;
                                      }
                                      return null;
                                    },
                                  ),
                                ),
                              ],
                            ),
                            const SizedBox(height: 10),
                            // Text(
                            //   S.of(context).birthday,
                            //   style: labelTextStyle,
                            // ),
                            // const SizedBox(height: 8),
                            // TextFormField(
                            //   controller: _birthdayController,
                            //   decoration: const InputDecoration(
                            //     suffixIcon: Icon(Icons.calendar_today),
                            //   ),
                            //   readOnly: true,
                            //   onTap: () {
                            //     // Acción para seleccionar la fecha
                            //   },
                            //   validator: (value) {
                            //     if (value == null || value.isEmpty) {
                            //       return S.of(context).pleaseEnterYourBirthday;
                            //     }
                            //     return null;
                            //   },
                            // ),
                            const SizedBox(height: 10),
                            Text(
                              S.of(context).country,
                              style: labelTextStyle,
                            ),
                            const SizedBox(height: 8),
                            GestureDetector(
                              onTap: () {
                                showCountryPicker(
                                  context: context,
                                  showPhoneCode: false,
                                  favorite: defaultCountry != null
                                      ? [defaultCountry!]
                                      : null,
                                  countryListTheme: CountryListThemeData(
                                    bottomSheetHeight:
                                        MediaQuery.of(context).size.height *
                                            0.85,
                                    textStyle: const TextStyle(
                                        height: 2, fontSize: 16.5),
                                  ),
                                  customFlagBuilder: (Country country) {
                                    return getDashFlagByCountryCode(
                                        country.countryCode);
                                  },
                                  onSelect: (Country country) {
                                    setState(() {
                                      if (_countryCodeController.text !=
                                          country.countryCode) {
                                        stateProvinceNameController.text = '';
                                        _stateProvinceCodeController.text = '';
                                        _cityCodeController.text = '';
                                        cityNameController.text = '';

                                        therapist.therapistInfo.location
                                            .stateProvince = '';
                                        therapist.therapistInfo.location.city =
                                            '';
                                      }

                                      _countryCodeController.text =
                                          country.countryCode;
                                      countryNameController.text =
                                          country.nameLocalized!;
                                      defaultCountry = country.countryCode;
                                    });
                                  },
                                );
                              },
                              child: AbsorbPointer(
                                child: TextFormField(
                                  textAlign: _countryCodeController.text.isEmpty
                                      ? TextAlign.center
                                      : TextAlign.start,
                                  controller: countryNameController,
                                  decoration: InputDecoration(
                                    hintText: '< ${S.of(context).selectHint} >',
                                    hintStyle: TextStyle(
                                      color: _countryCodeController.text.isEmpty
                                          ? Colors.black
                                          : (isDarkMode
                                              ? ThemeSettings
                                                  .hintTextColor.darkModePrimary
                                              : ThemeSettings.hintTextColor
                                                  .lightModePrimary),
                                    ),
                                    prefixIcon: _countryCodeController
                                            .text.isEmpty
                                        ? null
                                        : Padding(
                                            padding: const EdgeInsets.only(
                                                left: 15, right: 8),
                                            child: getDashFlagByCountryCode(
                                                _countryCodeController.text),
                                          ),
                                    prefixIconConstraints: const BoxConstraints(
                                      minWidth: 41,
                                      minHeight: 20,
                                    ),
                                  ),
                                ),
                              ),
                            ),
                            const SizedBox(height: 10),
                            Text(
                              S.of(context).stateProvince,
                              style: labelTextStyle,
                            ),
                            const SizedBox(height: 8),
                            GestureDetector(
                              onTap: () {
                                showCityStateSelectionModal(
                                  context,
                                  type: 'state',
                                  country: _countryCodeController.text,
                                  onSelect: (selectedItem) {
                                    state_utils.State stateProvinceSelected =
                                        selectedItem;

                                    setState(() {
                                      _stateProvinceCodeController.text =
                                          stateProvinceSelected.isoCode;
                                      stateProvinceNameController.text =
                                          stateProvinceSelected.name;
                                      _cityCodeController.clear();

                                      if (stateProvinceSelected.latitude !=
                                              null &&
                                          stateProvinceSelected.longitude !=
                                              null) {
                                        therapistGeolocation = GeoPoint(
                                            double.parse(stateProvinceSelected
                                                .latitude!),
                                            double.parse(stateProvinceSelected
                                                .longitude!));
                                      }
                                    });
                                  },
                                );
                              },
                              child: AbsorbPointer(
                                child: TextFormField(
                                  textAlign:
                                      _stateProvinceCodeController.text.isEmpty
                                          ? TextAlign.center
                                          : TextAlign.start,
                                  controller: stateProvinceNameController,
                                  decoration: InputDecoration(
                                    filled: _stateProvinceCodeController
                                            .text.isEmpty
                                        ? false
                                        : true,
                                    hintText: _stateProvinceCodeController
                                            .text.isEmpty
                                        ? '< ${S.of(context).selectHint} >'
                                        : '',
                                    hintStyle: TextStyle(
                                      color: _stateProvinceCodeController
                                              .text.isEmpty
                                          ? Colors.black
                                          : (isDarkMode
                                              ? ThemeSettings
                                                  .hintTextColor.darkModePrimary
                                              : ThemeSettings.hintTextColor
                                                  .lightModePrimary),
                                    ),
                                  ),
                                ),
                              ),
                            ),
                            const SizedBox(height: 10),
                            Text(
                              S.of(context).city,
                              style: labelTextStyle,
                            ),
                            const SizedBox(height: 8),
                            GestureDetector(
                              onTap: () {
                                showCityStateSelectionModal(
                                  context,
                                  type: 'city',
                                  country: _countryCodeController.text,
                                  state: _stateProvinceCodeController.text,
                                  onSelect: (selectedItem) {
                                    City citySelected = selectedItem;
                                    setState(() {
                                      _cityCodeController.text =
                                          citySelected.name;

                                      if (citySelected.latitude != null &&
                                          citySelected.longitude != null) {
                                        therapistGeolocation = GeoPoint(
                                            double.parse(
                                                citySelected.latitude!),
                                            double.parse(
                                                citySelected.longitude!));
                                      }
                                    });
                                  },
                                );
                              },
                              child: AbsorbPointer(
                                child: TextFormField(
                                  textAlign: _cityCodeController.text.isEmpty
                                      ? TextAlign.center
                                      : TextAlign.start,
                                  controller: _cityCodeController,
                                  decoration: InputDecoration(
                                    filled: _cityCodeController.text.isEmpty
                                        ? false
                                        : true,
                                    hintText: _cityCodeController.text.isEmpty
                                        ? '< ${S.of(context).selectHint} >'
                                        : '',
                                    hintStyle: TextStyle(
                                      color: _cityCodeController.text.isEmpty
                                          ? Colors.black
                                          : (isDarkMode
                                              ? ThemeSettings
                                                  .hintTextColor.darkModePrimary
                                              : ThemeSettings.hintTextColor
                                                  .lightModePrimary),
                                    ),
                                  ),
                                ),
                              ),
                            ),
                            const SizedBox(height: 10),
                            Text(
                              S.of(context).address,
                              style: labelTextStyle,
                            ),
                            const SizedBox(height: 8),
                            TextFormField(
                              controller: _addressController,
                              decoration: const InputDecoration(
                                hintText: '123 Main St.',
                              ),
                            ),
                            const SizedBox(height: 10),
                            Text(
                              S.of(context).zipCode,
                              style: labelTextStyle,
                            ),
                            const SizedBox(height: 8),
                            TextFormField(
                              controller: _zipController,
                              decoration: const InputDecoration(
                                hintText: '12345',
                              ),
                            ),

                            const SizedBox(height: 30),
                          ],
                        ),
                      ),
                    ),
                  ),
                  // About me Tab
                  SingleChildScrollView(
                    physics: ClampingScrollPhysics(),
                    child: Padding(
                      padding: const EdgeInsets.all(16.0),
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          const SizedBox(height: 10),
                          Text(
                            S.of(context).addSpecializations,
                            style: labelTextStyle,
                          ),
                          const SizedBox(height: 10),
                          AdvancedChipsInput(
                            paddingInsideWidgetContainer: EdgeInsets.zero,
                            controller: _specializationsController,
                            onSubmitted: (specializations) {
                              // setState(() {
                              //   _specializations.add(specializations);
                              // });
                            },
                            deleteIcon: Padding(
                              padding: const EdgeInsets.only(left: 7),
                              child: const Icon(
                                Icons.cancel,
                                size: 18,
                              ),
                            ),
                            marginBetweenChips:
                                EdgeInsets.only(bottom: 13, top: 2, right: 5),
                            paddingInsideChipContainer: const EdgeInsets.only(
                                left: 15, right: 15, top: 8, bottom: 8),
                            textFormFieldStyle: TextFormFieldStyle(
                              enableSuggestions: false,
                              decoration: InputDecoration(
                                focusedBorder: OutlineInputBorder(
                                  borderRadius:
                                      ThemeSettings.inputsBorderRadius,
                                  borderSide: BorderSide(
                                    color: isDarkMode
                                        ? ThemeSettings
                                            .primaryTextColor.darkModePrimary
                                        : ThemeSettings
                                            .primaryTextColor.lightModePrimary,
                                  ),
                                ),
                                hintText: S.of(context).addSpecializations,
                                hintStyle: TextStyle(
                                  color: isDarkMode
                                      ? ThemeSettings
                                          .hintTextColor.darkModePrimary
                                      : ThemeSettings
                                          .hintTextColor.lightModePrimary,
                                ),
                              ),
                            ),
                            separatorCharacter: ' ',
                            placeChipsSectionAbove: true,
                            chipContainerDecoration: BoxDecoration(
                              border: Border.all(
                                width: 1,
                                color: isDarkMode
                                    ? ThemeSettings
                                        .primaryTextColor.darkModePrimary
                                    : ThemeSettings
                                        .primaryTextColor.lightModePrimary,
                              ),
                              color: isDarkMode
                                  ? ThemeSettings
                                      .inputBackgroundColor.darkModePrimary
                                  : ThemeSettings
                                      .inputBackgroundColor.lightModePrimary,
                              borderRadius: ThemeSettings.inputsBorderRadius,
                            ),
                            chipTextStyle: TextStyle(
                                fontWeight: FontWeight.w600,
                                fontSize: 14,
                                color: isDarkMode
                                    ? ThemeSettings
                                        .primaryTextColor.darkModePrimary
                                    : ThemeSettings
                                        .primaryTextColor.lightModePrimary),
                            validateInput: true,
                            validateInputMethod: (value) {
                              if (value.length < 3) {
                                return 'Input should be at least 3 characters long';
                              }
                              return null;
                            },
                            onChipDeleted: (chipText, index) {
                              print('Deleted chip: $chipText at index $index');
                            },
                          ),
                          // TextFormField(
                          //   decoration: InputDecoration(
                          //     suffixIcon: IconButton(
                          //       icon: const Icon(Icons.add),
                          //       onPressed: () {
                          //         // Acción para agregar especialización
                          //       },
                          //     ),
                          //   ),
                          // ),
                          const SizedBox(height: 10),
                          Text(
                            S.of(context).addSpokenLanguages,
                            style: labelTextStyle,
                          ),
                          const SizedBox(height: 10),
                          GestureDetector(
                            onTap: () => showLanguageSelectionModal(
                              context,
                              selectedLanguages: selectedLanguages,
                              onLanguagesSelected: _updateSelectedLanguages,
                            ),
                            child: AbsorbPointer(
                              child: Container(
                                width: double.infinity,
                                padding: const EdgeInsets.symmetric(
                                    vertical: 13, horizontal: 12),
                                decoration: BoxDecoration(
                                  color: isDarkMode
                                      ? ThemeSettings
                                          .inputBackgroundColor.darkModePrimary
                                      : ThemeSettings.inputBackgroundColor
                                          .lightModePrimary,
                                  border: Border.all(
                                      color: isDarkMode
                                          ? ThemeSettings
                                              .primaryTextColor.darkModePrimary
                                          : ThemeSettings.primaryTextColor
                                              .lightModePrimary),
                                  borderRadius:
                                      ThemeSettings.inputsBorderRadius,
                                ),
                                child: Row(
                                  mainAxisAlignment:
                                      MainAxisAlignment.spaceBetween,
                                  children: [
                                    Flexible(
                                        child: buildLanguageText(context,
                                            selectedLanguages:
                                                selectedLanguages)),
                                    const Icon(Icons.add, size: 23),
                                  ],
                                ),
                              ),
                            ),
                          ),
                          const SizedBox(height: 16),
                          Text(
                            '${S.of(context).meetingType}:',
                            style: labelTextStyle,
                          ),
                          const SizedBox(height: 8),
                          Row(
                            children: [
                              Checkbox(
                                value: _presential,
                                onChanged: (bool? value) {
                                  setState(() {
                                    _presential = !_presential;
                                    therapist.therapistInfo.meetingType
                                            .presential =
                                        !therapist.therapistInfo.meetingType
                                            .presential;
                                  });
                                },
                              ),
                              Text(
                                S.of(context).presential,
                                style: Theme.of(context).textTheme.titleMedium,
                              ),
                            ],
                          ),
                          Row(
                            children: [
                              Checkbox(
                                value: _remote,
                                onChanged: (bool? value) {
                                  setState(() {
                                    _remote = !_remote;
                                    therapist.therapistInfo.meetingType.remote =
                                        !therapist
                                            .therapistInfo.meetingType.remote;
                                  });
                                },
                              ),
                              Text(
                                S.of(context).remote,
                                style: Theme.of(context).textTheme.titleMedium,
                              ),
                            ],
                          ),
                          SizedBox(height: 16),
                          Text(
                            S.of(context).intro,
                            style: labelTextStyle,
                          ),
                          SizedBox(height: 8),
                          TextFormField(
                            controller: _introController,
                            maxLines: 3,
                            validator: (value) {
                              if (value == null || value.isEmpty) {
                                return S.of(context).pleaseEnterYourIntro;
                              }
                              return null;
                            },
                          ),
                          const SizedBox(height: 10),
                          Text(
                            S.of(context).publicPresentation,
                            style: labelTextStyle,
                          ),
                          SizedBox(height: 8),
                          TextFormField(
                            controller: _publicPresentationController,
                            scrollPhysics: const ClampingScrollPhysics(),
                            maxLines: 8,
                            validator: (value) {
                              if (value == null || value.isEmpty) {
                                return S
                                    .of(context)
                                    .pleaseEnterYourPublicPresentation;
                              }
                              return null;
                            },
                          ),
                          Divider(),
                          Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              Text(
                                S.of(context).privateNotes,
                                style: labelTextStyle,
                              ),
                              Text(
                                  ' (${S.of(context).privateNotesDescription})',
                                  style: Theme.of(context)
                                      .textTheme
                                      .titleMedium
                                      ?.copyWith(
                                        fontSize: 15,
                                      )),
                            ],
                          ),
                          SizedBox(height: 8),
                          Container(
                            decoration: BoxDecoration(
                              border: Border.all(
                                color: Colors.red.withOpacity(0.3)!,
                                width: 8,
                              ),
                              borderRadius: BorderRadius.circular(18),
                            ),
                            child: TextFormField(
                              controller: _privateNotesController,
                              maxLines: 6,
                            ),
                          ),
                        ],
                      ),
                    ),
                  ),
                ],
              ),
            ),
          ),
          Container(
            width: double.infinity,
            padding: const EdgeInsets.all(16.0),
            decoration: BoxDecoration(
              color: Theme.of(context).scaffoldBackgroundColor,
              boxShadow: [
                BoxShadow(
                  color: Colors.black.withOpacity(0.08),
                  blurRadius: 1.0,
                  offset: Offset(0, -0.8),
                ),
              ],
            ),
            child: ElevatedButton(
              onPressed: savingChanges ? null : _saveChanges,
              style: ElevatedButton.styleFrom(
                padding: EdgeInsets.symmetric(vertical: 16),
              ),
              child: savingChanges
                  ? Row(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        Text(S.of(context).savingChanges),
                        SizedBox(width: 8),
                        const SizedBox(
                            width: 12,
                            height: 12,
                            child: LoadingCircle(
                              strokeWidth: 2.5,
                            ))
                      ],
                    )
                  : Text(S.of(context).saveChanges),
            ),
          ),
        ],
      ),
    );
  }
}

